<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Looper Pedal App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <style>
    /* --- Global & Layout --- */
    :root {
      --pedal-bg: repeating-linear-gradient(135deg, #2a2d33 0px, #2a2d33 5px, #2c2f36 5px, #2c2f36 11px), linear-gradient(135deg, #2c2f36 80%, #1a1b1f 100%);
      --pedal-shadow: 0 6px 40px #10172a3a, 0 3px 8px #222b352f;
      --pedal-border-radius: 22px;
      --text-primary: #f5f6fa;
      --text-secondary: #c0c5d4;
      --accent-green: #21f7a8;
      --accent-blue: #38b6ff;
      --accent-pink: #f472b6;
      --accent-yellow: #fde047;
      --accent-purple: #a78bfa;
      --accent-red: #f43f5e;
    }
    html {
      overflow-y: auto;
    }
    body {
      background: linear-gradient(135deg, #191b22 0%, #23283a 100%);
      color: var(--text-primary);
      font-family: 'Segoe UI', 'Roboto', 'Arial', sans-serif;
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      overflow-x: hidden;
    }
    /* Start Overlay for user interaction */
    #start-overlay {
        position: fixed;
        inset: 0;
        background: rgba(12, 20, 30, 0.95);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 10000;
        color: white;
        text-align: center;
        padding: 20px;
    }
    #start-overlay h2 {
        font-size: 2em;
        margin-bottom: 20px;
    }
    #start-overlay p {
        max-width: 500px;
        margin-bottom: 30px;
        color: var(--text-secondary);
    }
    #startBtn {
        padding: 15px 40px;
        font-size: 1.5em;
        font-weight: bold;
        border: none;
        border-radius: 15px;
        cursor: pointer;
        background: linear-gradient(90deg, #265cff 0%, #22ffe8 100%);
        color: #fff;
        box-shadow: 0 4px 20px #00d9ff66;
        transition: all 0.2s;
    }
     #startBtn:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 25px #00d9ff88;
     }

    .main-wrapper {
      padding: 20px;
      box-sizing: border-box;
      width: 100%;
      visibility: hidden; /* Hide until app starts */
    }

    /* --- NEW LAYOUT CONTAINERS --- */
    .pedal-board-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 30px;
    }
    .main-pedals-container {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        gap: 30px;
        width: 100%;
    }
    .control-pedals-container {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        gap: 30px;
        width: 100%;
        order: 1; 
    }
    .utility-pedals-container {
        display: flex;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: center;
        gap: 30px;
        width: 100%;
        order: 2; 
    }

    /* --- Horizontal Performance Panel (New Layout) --- */
    #horizontalPerformancePanel {
        width: 100%;
        max-width: 100%;
        background: var(--pedal-bg);
        border-radius: var(--pedal-border-radius);
        box-shadow: var(--pedal-shadow);
        padding: 20px;
        box-sizing: border-box;
        display: flex;
        justify-content: space-around;
        gap: 30px;
        border-top: 5px solid #f472b6;
        margin-bottom: 30px; 
    }

    #horizontalPerformancePanel .perf-section { 
        flex: 1; 
        max-width: 450px; /* Allow sections to grow wide in desktop view */
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
    }

    @media (max-width: 900px) {
        #horizontalPerformancePanel {
            flex-direction: column; /* Stack sections vertically on small screens */
            gap: 20px;
        }
        #horizontalPerformancePanel .perf-section {
            max-width: 100%;
        }
    }


    /* --- Header --- */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      flex-wrap: wrap;
      gap: 15px;
    }
    .header h1 {
        font-size: 1.5rem;
        color: var(--text-primary);
        text-shadow: 0 1px 5px #00000055;
    }
    #bpmLabel {
        background: #1c2432;
        padding: 8px 18px;
        border-radius: 13px;
        font-weight: bold;
        font-size: 1.18em;
        box-shadow: 0 2px 14px #0006;
        color: #a7ffed;
        letter-spacing: 1px;
    }

    /* --- Pedal Units --- */
    .pedal-unit {
      background: var(--pedal-bg);
      border-radius: var(--pedal-border-radius);
      box-shadow: var(--pedal-shadow);
      padding: 24px;
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 280px;
      min-height: 480px;
      box-sizing: border-box;
      border-top: 5px solid transparent;
      transition: box-shadow 0.2s ease;
      position: relative; 
    }
    .pedal-unit h4 {
      font-size: 1.15em;
      font-weight: bold;
      color: var(--text-secondary);
      margin-bottom: 20px;
      letter-spacing: 1.5px;
      text-align: center;
      text-transform: uppercase;
    }

    /* --- Before FX Pedal (UI Fix Applied Here) --- */
    .before-fx-pedal {
      border-top-color: var(--accent-green);
      justify-content: flex-start;
      gap: 12px;
    }
    
    .pre-fx-list {
        list-style: none;
        padding: 0;
        width: 100%;
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-bottom: 15px;
    }
    .pre-fx-list li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: #1a202c;
        border-radius: 8px;
        padding: 6px 8px; /* Tighter padding */
        box-shadow: 0 1px 4px #0005;
        border-left: 5px solid transparent;
        transition: all 0.2s;
    }
    .pre-fx-list li.active {
        border-left-color: var(--accent-green);
        background: #1f2937;
    }
    .pre-fx-list li .fx-controls {
        display: flex; 
        align-items: center;
        gap: 4px; /* Tighter spacing */
    }
    .pre-fx-list li .fx-controls button {
        background: #475569;
        color: var(--text-primary);
        border: none;
        padding: 3px 5px; /* Smaller button size */
        border-radius: 6px;
        font-size: 0.75em; /* Smaller font */
        margin-left: 0; /* Use gap for spacing */
        cursor: pointer;
    }
    .pre-fx-list .fx-name {
        font-weight: bold;
        min-width: 70px; /* Reduced min-width to make space */
    }
    .pre-fx-list .fx-controls button:hover {
        background: #64748b;
    }
    .pre-fx-menu-btn {
        margin-top: 10px;
        width: 90%;
        background: linear-gradient(90deg, #fde047 0%, #fbbf24 100%);
        color: #2b2341;
    }
    .pre-fx-menu-btn:hover {
        filter: brightness(1.1);
    }
    
    /* --- Looper Track Delete Button (new) --- */
    .delete-track-btn {
        position: absolute;
        top: 10px;
        left: 10px;
        background: var(--accent-red);
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        font-size: 1.2em;
        font-weight: bold;
        line-height: 1;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 5px #0005;
        z-index: 10;
        transition: transform 0.1s;
    }
    .delete-track-btn:hover {
        transform: scale(1.1);
    }


    /* --- Looper Pedal --- */
    .looper-pedal {
      padding: 24px;
    }
    #looper1 { border-top-color: var(--accent-green); }
    #looper2 { border-top-color: var(--accent-blue); }
    #looper3 { border-top-color: var(--accent-pink); }
    #looper4 { border-top-color: var(--accent-yellow); }
    .track-label {
      font-size: 1.2em;
      font-weight: bold;
      color: var(--text-secondary);
      margin-bottom: 15px;
      letter-spacing: 1.5px;
    }
    .display-area {
      position: relative;
      width: 100px;
      height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 20px;
    }
    .progress-ring {
      width: 100px;
      height: 100px;
    }
    .progress-ring circle {
      stroke: var(--accent-green);
      stroke-width: 7;
      fill: none;
      stroke-linecap: round;
      transform-origin: 50% 50%;
      transform: rotate(-90deg);
      transition: stroke 0.3s ease, filter 0.3s ease;
    }
    .looper-icon {
      position: absolute;
      font-size: 2.8em;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 2px 13px #0008;
      z-index: 2;
    }
    .state-display {
      min-width: 80px;
      font-size: 1.1em;
      color: #d0e8f7;
      background: #161a2c9a;
      border-radius: 8px;
      padding: 6px 14px;
      text-align: center;
      font-weight: 500;
      letter-spacing: 1px;
      box-shadow: 0 2px 8px #0005;
      margin-bottom: 15px;
    }
    .controls-area {
        width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
        margin-bottom: 20px;
    }
    .looper-vol-label {
      display: flex;
      align-items: center;
      font-size: 1.04em;
      background: #1b2233a0;
      border-radius: 9px;
      padding: 3px 10px 3px 8px;
      gap: 7px;
      box-shadow: 0 1px 5px #0cfbfc18;
      color: #d0ffe1;
      width: 90%;
    }
    .looper-vol-slider {
      width: 100%;
      margin: 0 8px;
      accent-color: #3ad7bf;
      height: 6px;
      border-radius: 6px;
    }
    .looper-vol-label span:last-child {
      min-width: 38px;
      text-align: right;
      color: #88ffe6;
      font-weight: 500;
    }
    .track-fx-labels {
      font-size: .9em;
      color: #ffed91;
      min-height: 20px;
      text-align: center;
      width: 90%;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    select {
      padding: 6px 15px;
      font-size: 1em;
      border-radius: 9px;
      border: none;
      background: #1a243f;
      color: #e1e7fe;
      outline: none;
      cursor: pointer;
      width: 90%;
    }
    .button-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
        width: 100%;
        margin-top: auto;
    }
    .fx-menu-btn {
        grid-column: 1 / -1; 
    }

    /* --- Add Looper & Other Pedals --- */
    #addLooperBtn {
        justify-content: center;
        cursor: pointer;
        font-size: 5em;
        color: #6b7280;
        border: 4px dashed #4b5563;
        transition: background-color 0.2s, color 0.2s;
    }
    #addLooperBtn:hover {
        background-color: #2d3748;
        color: #a0aec0;
    }

    #overdubSettingsContainer, #calibrationContainer {
        border-top-color: #fca5a5;
        justify-content: center;
        gap: 15px;
    }
    #calibrationContainer { border-top-color: #fde047; }


    #overdubSettings label {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      font-size: 1.1em;
    }
    #overdubSettings input[type="range"] {
        width: 80%;
        margin-top: 8px;
    }

    /* --- Buttons --- */
    .btn {
      padding: 13px 20px;
      font-size: 1.1em;
      font-weight: bold;
      border: none;
      border-radius: 14px;
      cursor: pointer;
      box-shadow: 0 3px 14px #0006;
      transition: all 0.15s;
      width: 100%;
      text-align: center;
    }
    .before-fx-btn { background: #222b33; border: 2px solid var(--accent-green); color: #9fffe6; }
    .before-fx-btn.active { background: linear-gradient(90deg,#11ffbe 0%,#265cff 100%); color: #151a2a; border-color: #2dd4bf; box-shadow: 0 4px 24px #00ffc880; }
    .main-looper-btn { background: linear-gradient(90deg, #265cff 0%, #22ffe8 100%); color: #fff; }
    .stop-btn { background: linear-gradient(90deg, var(--accent-red) 0%, #fbbf24 100%); color: #fff; }
    .fx-menu-btn { background: linear-gradient(90deg,var(--accent-yellow) 0%,var(--accent-blue) 100%); color: #2b2341; }
    .monitor-btn { background: linear-gradient(90deg,#00ffd0 0%,#214080 100%); color: #23263c; }
    .monitor-btn.active { background: linear-gradient(90deg,#fde047 0%,#ffb347 100%) !important; color: #443000 !important; }
    .btn:active { transform: scale(0.97); filter: brightness(1.15); }
    .disabled-btn { opacity: 0.55 !important; cursor: not-allowed !important; filter: grayscale(0.7); }

    /* --- COMBINED FX CONTROL Pedal (Wider container) --- */
    #fxControlContainer {
        border-top-color: var(--accent-purple);
        justify-content: flex-start;
        flex-grow: 2; 
        min-width: 400px;
        max-width: 600px;
        min-height: 480px;
    }

    .fx-control-grid {
        display: grid;
        grid-template-columns: 1fr; 
        gap: 15px;
        width: 100%;
        margin-bottom: 15px;
    }

    /* --- Combined Slider Wrapper (FX Control & Auto-FX) --- */
    .combined-fx-slider-wrapper {
        display: grid;
        grid-template-columns: 35px 1fr 60px; 
        grid-template-rows: auto auto;
        gap: 5px 10px;
        width: 100%;
        background: #1a202c88;
        padding: 10px;
        border-radius: 10px;
        border: 2px solid transparent;
        transition: all 0.3s;
    }
    .combined-fx-slider-wrapper.assignable {
        cursor: pointer;
        border-color: var(--accent-yellow);
        animation: pulse 1.5s infinite;
    }
    .combined-fx-slider-label {
        grid-column: 2 / 3; 
        grid-row: 1 / 2;
        font-size: 0.85em;
        font-weight: bold;
        color: var(--text-secondary);
        white-space: nowrap;
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .fx-slider-controls {
        grid-column: 1 / 2;
        grid-row: 2 / 3;
        display: flex;
        flex-direction: column;
        gap: 8px;
        align-items: center;
        justify-content: center;
    }
    .fx-slider-input-area {
        grid-column: 2 / 3;
        grid-row: 2 / 3;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
    }
    .fx-slider-input-area input[type="range"] {
        width: 100%;
        margin-bottom: 4px;
        accent-color: var(--accent-blue);
    }
    .fx-slider-value {
        grid-column: 3 / 4;
        grid-row: 2 / 3;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
        font-size: 1.1em;
        color: var(--accent-green);
    }

    .led-btn {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        border: 2px solid #334155;
        background-color: #475569;
        cursor: pointer;
        transition: background-color 0.2s, box-shadow 0.2s;
    }
    .led-btn.active {
        background-color: var(--accent-green);
        border-color: #16a34a;
        box-shadow: 0 0 12px var(--accent-green);
    }
    .edit-automation-btn {
        padding: 4px 6px;
        font-size: 0.8em;
        font-weight: bold;
        border-radius: 6px;
        background: #334155;
        color: var(--text-primary);
    }
     .edit-automation-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
     }

     #mic-monitor-wrapper {
        margin-top: auto;
        width: 100%;
        display: flex;
        gap: 15px;
    }

    /* --- Popups --- */
    .fx-popup { position: fixed; inset: 0; background: rgba(12,20,30,0.86); display: flex; align-items: center; justify-content: center; z-index: 9999; overflow-y: auto; padding: 1rem;}
    .fx-popup-inner { background: #24293a; border-radius: 16px; padding: 26px; min-width: 320px; max-width: 94vw; max-height: 90vh; overflow-y: auto; box-shadow: 0 8px 48px #000a; color: #f1f8fa; }
    .fx-popup h3 { font-size: 1.22em; margin-top: 0; }
    .fx-popup label { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; font-size: 1.07em; flex-wrap: wrap; }
    .fx-popup input[type="range"] { width: 60%; min-width: 98px; max-width: 240px; vertical-align: middle; accent-color: #2ed7ff; margin-left: 7px; }
    .fx-popup button { margin-right: 8px; margin-top: 12px; padding: 7px 22px; border-radius: 9px; border: none; font-weight: 700; font-size: 1.04em; background: linear-gradient(90deg,#22ffe8 0%,#265cff 100%); color: #23263c; cursor: pointer;}
    .fx-popup .btn-trigger { width: 100%; padding: 12px; margin-top: 15px; background: linear-gradient(90deg, #f43f5e 0%, #fbbf24 100%); color: #fff; font-size: 1.1em;}
    .fx-list { list-style: none; padding: 0; }
    .fx-list li { display: flex; align-items: center; justify-content: space-between; padding: 8px; background: #1a202c; border-radius: 8px; margin-bottom: 8px; }
    .fx-list .fx-name { font-weight: bold; }
    .fx-list .fx-controls button { font-size: 0.9em; padding: 4px 8px; }
    .btn-link-fx {
        padding: 2px 6px;
        font-size: 0.8em;
        margin-left: 10px;
        border-radius: 5px;
        cursor: pointer;
        background: #4a5568;
        color: white;
        border: 1px solid #718096;
    }
    .btn-link-fx.linked {
        background: var(--accent-green);
        color: #1a202c;
    }

    .hidden { display: none !important; }

    /* --- Automation Graph Popup --- */
    #automationCanvas, #volumeGraphCanvas {
        background-color: #1e293b;
        border-radius: 8px;
        cursor: crosshair;
        touch-action: none; 
        max-width: 100%;
        height: auto;
    }
    
    /* --- Volume Preset Pedal (Standard width container) --- */
    #volumeControlContainer {
        border-top-color: var(--accent-blue);
        justify-content: flex-start;
        gap: 15px;
        width: 280px; 
        min-height: 480px;
        flex-shrink: 0; 
    }
    
    .preset-grid {
        display: grid;
        grid-template-columns: 1fr; 
        gap: 15px;
        width: 100%;
    }
    .preset-btn-wrapper {
        display: flex;
        gap: 8px;
        align-items: center;
    }
    .preset-btn-wrapper .btn {
        flex-grow: 1;
    }
    .edit-preset-btn {
        padding: 10px;
        font-size: 1.2em;
        background: #334155;
        min-width: 45px;
    }

    /* --- Volume Preset Popup --- */
    .preset-popup-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 15px;
        max-height: 50vh;
        overflow-y: auto;
        padding: 10px;
        background: #1a202c;
        border-radius: 8px;
        margin-bottom: 15px;
    }
    .preset-track-editor {
        background: #1e293b;
        border-radius: 8px;
        padding: 15px;
        margin-bottom: 15px;
    }
    .preset-track-editor h5 {
        margin-top: 0;
        margin-bottom: 10px;
        color: var(--accent-blue);
    }
    .preset-editor-controls {
        display: flex;
        gap: 10px;
        margin-top: 10px;
        align-items: center;
    }
    .preset-editor-controls button {
        padding: 4px 8px;
        font-size: 0.9em;
    }
    #presetGraphCanvas {
        background-color: #1a202c;
        border-radius: 4px;
        cursor: crosshair;
        touch-action: none;
        max-width: 100%;
        height: auto;
        margin-top: 10px;
        border: 1px solid #334155;
    }
    .curve-multiplier-select {
        padding: 4px 8px;
        border-radius: 6px;
        background: #334155;
        color: var(--text-primary);
        border: none;
        outline: none;
        font-size: 0.9em;
    }
    
    /* NEW: Graph Button in Preset Editor */
    .graph-edit-btn {
        padding: 4px 10px;
        font-size: 0.9em;
        background: var(--accent-purple);
        color: white;
        border-radius: 8px;
        cursor: pointer;
    }
    .graph-button-group {
        display: flex;
        gap: 8px;
        margin-top: 10px;
        justify-content: center;
        width: 100%;
    }


  
    /* Performance Pedal Styles */
    .perf-section-label {
        font-size: 0.85em;
        font-weight: bold;
        color: var(--text-secondary);
        margin-bottom: 10px;
        width: 100%;
        text-align: center;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    .perf-pad-grid, .perf-switch-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        width: 100%;
    }
    .perf-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        flex: 1; /* Use flex to distribute space evenly within the horizontal panel */
    }
    .perf-pad {
        width: 100%;
        aspect-ratio: 1;
        background: #334155;
        border: 2px solid #475569;
        border-radius: 8px;
        color: #f1f5f9;
        font-size: 1.5em;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.1s;
        box-shadow: 0 4px 0 #1e293b;
    }
    /* NEW: Trigger Glow when linked */
    .perf-pad.linked {
        background: var(--accent-green);
        box-shadow: 0 0 10px var(--accent-green) !important;
        color: #1a202c;
    }
    .perf-pad:active {
        transform: translateY(4px);
        box-shadow: 0 0 0 #1e293b;
        background: #fde047;
        color: #1a202c;
        border-color: #fde047;
    }
    .perf-switch-wrapper { 
        position: relative;
        width: 100%;
    }
    .perf-switch-settings {
        position: absolute;
        top: 0;
        right: 0;
        padding: 4px;
        background: #1a202c;
        border: 1px solid #475569;
        border-radius: 0 6px 0 6px;
        cursor: pointer;
        transition: background 0.2s;
        z-index: 5;
    }
    .perf-switch-settings:hover {
        background: #334155;
    }
    .perf-switch {
        width: 100%;
        padding: 15px 0;
        background: #1e293b;
        border: 1px solid #334155;
        border-radius: 6px;
        color: var(--text-secondary);
        font-weight: bold;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: inset 0 2px 4px #0005;
    }
    .perf-switch.active {
        background: #38b6ff;
        color: #1a202c;
        box-shadow: 0 0 10px #38b6ff;
        border-color: #60a5fa;
    }
    .btn-assign-small {
        font-size: 0.8em;
        background: transparent;
        border: 1px solid #475569;
        color: #94a3b8;
        padding: 2px 8px;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s;
    }
    .btn-assign-small.learning {
        background: #f43f5e;
        color: white;
        border-color: #f43f5e;
        animation: pulse 1s infinite;
    }
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.6; }
    }
    
  </style>
</head>
<body>
  
  <div id="start-overlay">
    <h2>Looper Pedal App</h2>
    <p>Click "Start" to initialize the audio engine. For this app to work, you will need to grant microphone permissions when prompted.</p>
    <p><small>If you are running this as a local file, please use a local server (like VS Code's Live Server) for the audio features to work correctly.</small></p>
    <button id="startBtn">Start</button>
  </div>

  <div class="main-wrapper">
    <div class="header">
      <h1>Looper Board</h1>
      <span id="bpmLabel">BPM: --</span>
    </div>

    <div class="pedal-board-wrapper">
      <div class="main-pedals-container">
        <!-- 1. Before FX -->
        <div class="pedal-unit before-fx-pedal">
          <h4>PRE-LOOP FX CHAIN</h4>
          
          <!-- Audio Visualizer -->
          <canvas id="preFxVisualizer" width="232" height="100" style="background: #111827; border-radius: 8px; margin-bottom: 10px;"></canvas>
          <button id="vizToggleBtn" class="btn" style="background: #4a5568; font-size: 0.9em; padding: 8px; margin-bottom: 15px; width: 90%;">View Waveform</button>
          
          <ul id="preFxList" class="pre-fx-list">
              <!-- FX list items injected by JS -->
          </ul>
          
          <button class="btn pre-fx-menu-btn" id="openPreFxMenuBtn">Manage FX</button>

        </div>

        <!-- 2. Looper 1: Master -->
        <div class="pedal-unit looper-pedal" id="looper1">
          <div class="track-label">MASTER</div>
          <div class="display-area">
              <svg class="progress-ring"><circle id="progressBar1" r="46" cx="50" cy="50" /></svg>
              <div class="looper-icon" id="looperIcon1">‚ñ∂</div>
          </div>
          <div class="state-display" id="stateDisplay1">Ready</div>
          <div class="controls-area">
              <label class="looper-vol-label"><span>Vol</span><input type="range" class="looper-vol-slider" id="volSlider1" min="0" max="120" value="90" /><span id="volValue1">90%</span></label>
              <div class="track-fx-labels" id="trackFxLabels1"></div>
          </div>
          <div class="button-grid">
              <button class="btn main-looper-btn" id="mainLooperBtn1">Record</button>
              <button class="btn stop-btn" id="stopBtn1">Stop/Clear</button>
              <button class="btn fx-menu-btn" id="fxMenuBtn1">üéõ FX Menu</button>
          </div>
        </div>

        <!-- 3. Looper 2 -->
        <div class="pedal-unit looper-pedal" id="looper2">
          <button class="delete-track-btn" data-track-id="2">‚úï</button>
          <div class="track-label">TRACK 2</div>
          <div class="display-area">
              <svg class="progress-ring"><circle id="progressBar2" r="46" cx="50" cy="50" style="stroke: var(--accent-blue)"/></svg>
              <div class="looper-icon" id="looperIcon2">‚ñ∂</div>
          </div>
          <div class="state-display" id="stateDisplay2">Ready</div>
          <div class="controls-area">
              <label class="looper-vol-label"><span>Vol</span><input type="range" class="looper-vol-slider" id="volSlider2" min="0" max="120" value="90" /><span id="volValue2">90%</span></label>
              <div class="track-fx-labels" id="trackFxLabels2"></div>
              <select id="divider2"><option value="1">x1</option><option value="0.5">x¬Ω</option><option value="2">x2</option></select>
          </div>
          <div class="button-grid">
              <button class="btn main-looper-btn" id="mainLooperBtn2">Record</button>
              <button class="btn stop-btn" id="stopBtn2">Stop/Clear</button>
              <button class="btn fx-menu-btn" id="fxMenuBtn2">üéõ FX Menu</button>
          </div>
        </div>

        <!-- 4. Looper 3 -->
        <div class="pedal-unit looper-pedal" id="looper3">
          <button class="delete-track-btn" data-track-id="3">‚úï</button>
          <div class="track-label">TRACK 3</div>
          <div class="display-area">
              <svg class="progress-ring"><circle id="progressBar3" r="46" cx="50" cy="50" style="stroke: var(--accent-pink)"/></svg>
              <div class="looper-icon" id="looperIcon3">‚ñ∂</div>
          </div>
          <div class="state-display" id="stateDisplay3">Ready</div>
          <div class="controls-area">
              <label class="looper-vol-label"><span>Vol</span><input type="range" class="looper-vol-slider" id="volSlider3" min="0" max="120" value="90" /><span id="volValue3">90%</span></label>
              <div class="track-fx-labels" id="trackFxLabels3"></div>
              <select id="divider3"><option value="1">x1</option><option value="0.5">x¬Ω</option><option value="2">x2</option></select>
          </div>
          <div class="button-grid">
              <button class="btn main-looper-btn" id="mainLooperBtn3">Record</button>
              <button class="btn stop-btn" id="stopBtn3">Stop/Clear</button>
              <button class="btn fx-menu-btn" id="fxMenuBtn3">üéõ FX Menu</button>
          </div>
        </div>

        <!-- 5. Add Looper Button -->
        <div id="addLooperBtn" class="pedal-unit">
          +
        </div>
      </div>

      <!-- NEW: Horizontal Performance Panel -->
      <div id="horizontalPerformancePanel">
        <div class="perf-section">
            <div class="perf-section-label">ONE-SHOT TRIGGERS</div>
            <div class="perf-pad-grid">
                <div class="perf-wrapper">
                    <button class="perf-pad" id="triggerPad1">T1</button>
                    <button class="btn-assign-small" id="assignTrigger0">üîó</button>
                </div>
                <div class="perf-wrapper">
                    <button class="perf-pad" id="triggerPad2">T2</button>
                    <button class="btn-assign-small" id="assignTrigger1">üîó</button>
                </div>
            </div>
        </div>

        <div class="perf-section">
            <div class="perf-section-label">FX MACROS (ON/OFF & AUTO)</div>
            <div class="perf-switch-grid">
                <div class="perf-wrapper">
                    <div class="perf-switch-wrapper">
                        <button class="perf-switch" id="macroBtn0">M1</button>
                        <button class="perf-switch-settings" data-macro-index="0">‚öôÔ∏è</button>
                    </div>
                    <button class="btn-assign-small" id="assignMacro0">üîó</button>
                </div>
                <div class="perf-wrapper">
                    <div class="perf-switch-wrapper">
                        <button class="perf-switch" id="macroBtn1">M2</button>
                        <button class="perf-switch-settings" data-macro-index="1">‚öôÔ∏è</button>
                    </div>
                    <button class="btn-assign-small" id="assignMacro1">üîó</button>
                </div>
                <div class="perf-wrapper">
                    <div class="perf-switch-wrapper">
                        <button class="perf-switch" id="macroBtn2">M3</button>
                        <button class="perf-switch-settings" data-macro-index="2">‚öôÔ∏è</button>
                    </div>
                    <button class="btn-assign-small" id="assignMacro2">üîó</button>
                </div>
                <div class="perf-wrapper">
                    <div class="perf-switch-wrapper">
                        <button class="perf-switch" id="macroBtn3">M4</button>
                        <button class="perf-switch-settings" data-macro-index="3">‚öôÔ∏è</button>
                    </div>
                    <button class="btn-assign-small" id="assignMacro3">üîó</button>
                </div>
            </div>
        </div>
      </div>
      <!-- END: Horizontal Performance Panel -->

      <div class="control-pedals-container">
        <!-- COMBINED FX AUTOMATION/CONTROL -->
        <div id="fxControlContainer" class="pedal-unit">
          <h4>FX AUTOMATION/CONTROL</h4>
          <div class="fx-control-grid" id="combined-fx-control-grid">
              <!-- Combined sliders will be injected by JS -->
          </div>
           <div id="mic-monitor-wrapper">
                <button id="monitorBtn" class="btn monitor-btn">Live MIC OFF</button>
           </div>
        </div>

        <!-- Volume Preset Control -->
        <div id="volumeControlContainer" class="pedal-unit">
          <h4>VOLUME PRESETS</h4>
          <div class="preset-grid">
              <div class="preset-btn-wrapper">
                  <button class="btn main-looper-btn" id="presetBtn_0">Preset 1</button>
                  <button class="btn edit-preset-btn" id="editPresetBtn_0">‚öôÔ∏è</button>
              </div>
              <div class="preset-btn-wrapper">
                  <button class="btn main-looper-btn" id="presetBtn_1">Preset 2</button>
                  <button class="btn edit-preset-btn" id="editPresetBtn_1">‚öôÔ∏è</button>
              </div>
              <div class="preset-btn-wrapper">
                  <button class="btn main-looper-btn" id="presetBtn_2">Preset 3</button>
                  <button class="btn edit-preset-btn" id="editPresetBtn_2">‚öôÔ∏è</button>
              </div>
              <div class="preset-btn-wrapper">
                  <button class="btn main-looper-btn" id="presetBtn_3">Preset 4</button>
                  <button class="btn edit-preset-btn" id="editPresetBtn_3">‚öôÔ∏è</button>
              </div>
          </div>
        </div>
      </div>

      <!-- Utility Pedals (Moved to the end) -->
      <div class="utility-pedals-container">
        <div id="overdubSettingsContainer" class="pedal-unit">
          <div id="overdubSettings">
              <h4>OVERDUB TUNING</h4>
              <label>Nudge (ms): <span id="nudgeVal">-20</span>
                  <!-- UPDATED min from -190 to -300 -->
                  <input id="nudgeMs" type="range" min="-300" max="150" step="1" value="-20">
              </label>
              <label>Gain: <span id="overdubGainVal">0.70</span>
                  <!-- UPDATED max from 2 to 0.70 and default value -->
                  <input id="overdubGain" type="range" min="0" max="0.70" step="0.01" value="0.70">
              </label>
          </div>
        </div>
        <div id="calibrationContainer" class="pedal-unit">
          <h4>LATENCY CALIBRATION</h4>
          <div style="text-align: center; padding: 10px; font-size: 0.9em; color: var(--text-secondary);">
              <p>For accurate overdubbing, calibrate your device's audio latency.</p>
              <p><strong>Instructions:</strong></p>
              <ol style="text-align: left; margin: 10px auto; max-width: 200px;">
                  <li>Disconnect headphones.</li>
                  <li>Turn volume up.</li>
                  <li>Press "Start Test".</li>
                  <li>Remain quiet.</li>
              </ol>
          </div>
          <button id="calibrateBtn" class="btn monitor-btn" style="margin-top: auto;">Start Test</button>
          <p id="calibrationResult" style="margin-top: 15px; font-weight: bold;">Result: Not yet run</p>
        </div>
      </div>
    </div>
  </div>

  <div id="startMsg" class="hidden"></div>
  <div id="fxMenuPopup" class="fx-popup hidden"></div>
  <div id="fxParamsPopup" class="fx-popup hidden"></div>
  <div id="fxBeforeParamsPopup" class="fx-popup hidden"></div>
  <div id="automationPopup" class="fx-popup hidden"></div>
  <div id="volumePresetPopup" class="fx-popup hidden"></div>
  <div id="preFxManagementPopup" class="fx-popup hidden"></div>
  <div id="macroManagementPopup" class="fx-popup hidden"></div>
  <!-- NEW: Volume Graph Popup -->
  <div id="volumeGraphPopup" class="fx-popup hidden"></div>

<script src="cordova.js"></script>
<script src="visualizer.js"></script>
<script>
// --- Start of Combined JavaScript ---

// Part 1: LooperRecorder (AudioWorklet based recorder)
(function(global){
  'use strict';
  const workletCode = `
  class LooperRecorderProcessor extends AudioWorkletProcessor {
    constructor(options) {
      super();
      this._buffers = [];
      this._channels = (options.processorOptions && options.processorOptions.channels) ? options.processorOptions.channels : 1;
      this._frameCount = 0;
      this._markPositions = [];
      this.port.onmessage = (ev) => {
        const d = ev.data;
        if (!d) return;
        if (d.cmd === 'clear') {
          this._buffers = []; this._frameCount = 0; this._markPositions = [];
        } else if (d.cmd === 'flush') {
          const r = { cmd:'flush-data', channels: [], markPositions: this._markPositions };
          if (this._frameCount === 0) { this.port.postMessage(r); return; }
          const perChan = [];
          for (let c=0;c<this._channels;c++){ perChan[c] = new Float32Array(this._frameCount); }
          let writeIndex = 0;
          for (let frame of this._buffers){
            const frameLen = frame[0].length;
            for (let ch=0; ch<this._channels; ch++){ const src = frame[ch] || frame[0]; perChan[ch].set(src, writeIndex); }
            writeIndex += frameLen;
          }
          for (let ch=0; ch<this._channels; ch++){ r.channels.push(perChan[c].buffer); }
          this.port.postMessage(r, r.channels);
          this._buffers = []; this._frameCount = 0; this._markPositions = [];
        } else if (d.cmd === 'markStart') {
          this._markPositions.push(this._frameCount);
        }
      };
    }
    process(inputs) {
      const ins = inputs[0];
      if (!ins || ins.length === 0) return true;
      const channelCount = Math.min(this._channels, ins.length);
      const block = [];
      const frameLen = ins[0].length;
      for (let ch = 0; ch < channelCount; ch++){ const copy = new Float32Array(frameLen); copy.set(ins[ch]); block.push(copy); }
      if (channelCount < this._channels) {
        for (let ch = channelCount; ch < this._channels; ch++){ const copy = new Float32Array(frameLen); copy.set(ins[0] || new Float32Array(frameLen)); block.push(copy); }
      }
      this._buffers.push(block);
      this._frameCount += frameLen;
      return true;
    }
  }
  registerProcessor('looper-recorder-processor', LooperRecorderProcessor);`;

  class LooperRecorder {
    constructor(audioCtx, sourceNode, opts = {}) {
      this.audioCtx = audioCtx; this.source = sourceNode; this.channels = opts.channels || 1;
      this._node = null; this.ondata = null; this._inited = false; this._workletUrl = null;
    }
    async init() {
      if (this._inited) return;
      try {
        const blob = new Blob([workletCode], { type: 'application/javascript' });
        this._workletUrl = URL.createObjectURL(blob);
        await this.audioCtx.audioWorklet.addModule(this._workletUrl);
        this._node = new AudioWorkletNode(this.audioCtx, 'looper-recorder-processor');
        this._node.port.onmessage = (ev) => {
          if (ev.data?.cmd === 'flush-data') {
            const channels = (ev.data.channels || []).map(buf => new Float32Array(buf));
            const marks = ev.data.markPositions || [];
            if (this.ondata) { try { this.ondata(channels, marks); } catch (err) { console.error('ondata error', err); } }
          }
        };
        this.source.connect(this._node);
        this._inited = true;
      } catch (e) {
        console.error("Failed to initialize LooperRecorder AudioWorklet.", e);
        // Fallback or error message could be handled here
      }
    }
    start() { if (!this._inited) throw new Error('init first'); this._node.port.postMessage({ cmd: 'clear' }); }
    markStart() { if (!this._inited) throw new Error('init first'); this._node.port.postMessage({ cmd: 'markStart' }); }
    stop() { if (!this._inited) throw new Error('init first'); this._node.port.postMessage({ cmd: 'flush' }); }
    destroy() {
        if (this._node) {
            try { this.source.disconnect(this._node); } catch(e) {}
            this._node.disconnect();
            this._node = null;
        }
        if (this._workletUrl) {
            URL.revokeObjectURL(this._workletUrl);
            this._workletUrl = null;
        }
        this._inited = false;
    }
  }
  global.LooperRecorder = LooperRecorder;
})(window);


// Part 2: Looper Engine Class
  // ===== Performance Assignments =====
  let triggerAssignments = [null, null];
  // Macro assignments now holds two types of objects:
  // 1. { type: 'fx', looperIndex, fxId } (for bypass/unbypass)
  // 2. { type: 'control', controlIndex } (for automation toggle)
  let macroAssignments = [[], [], [], []];
  let learningState = { type: null, index: null };

class LooperEngine {
    constructor() {
        this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive', sampleRate: 44100 });
        this.loopers = [];
        this.looperCount = 3;

        // Audio Graph Nodes
        this.micStream = null;
        this.micSource = null;
        this.dryGain = null;
        this.fxSumGain = null;
        this.recordingSourceMixer = null;
        this.liveMicMonitorGain = null;
        this.liveMicMonitoring = false;

        // Recorder
        this.recorder = null;
        this.activeRecorderLooper = null;
        this.isCalibrating = false;

        // Master Timing
        this.masterLoopDuration = null;
        this.masterBPM = null;
        this.masterIsSet = false;
        this.globalAnimationId = null;

        // NEW: Active Preset Curve
        this.activePresetTimeChain = {}; // {trackId: {startTime, duration, points}}


        // Callbacks
        this.onBpmUpdate = null;
        this.onFirstLoopCallback = null;

        this.$ = s => document.querySelector(s);

        this.showMsg = (msg, color = '#ff4444') => {
            let el = this.$('#startMsg');
            if (!el) return;
            el.style.display = 'block';
            el.innerHTML = msg;
            el.style.color = color;
            el.classList.remove('hidden');
            setTimeout(() => el.classList.add('hidden'), 4000);
        };

        this.clamp = (v, lo, hi) => Math.min(hi, Math.max(lo, v));
    }

    async ensureMic() {
        if (this.micStream) return;
        try {
            // REMOVED: await this.audioCtx.resume(); // RESUME IS NOW IN THE CLICK HANDLER
            this.micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
            this.micSource = this.audioCtx.createMediaStreamSource(this.micStream);
            this.setupAudioGraph();

            if (window.LooperRecorder && !this.recorder) {
                this.recorder = new LooperRecorder(this.audioCtx, this.recordingSourceMixer, { channels: 1 });
                await this.recorder.init();
                this.recorder.ondata = this.handleWorkletData.bind(this);
            }
        } catch (e) {
            this.showMsg('‚ùå Microphone access denied.');
            console.error("Mic access error", e);
            throw e;
        }
    }

    setupAudioGraph() {
        this.dryGain = this.audioCtx.createGain();
        this.dryGain.gain.value = 1;
        this.fxSumGain = this.audioCtx.createGain();
        this.fxSumGain.gain.value = 1;
        
        // Use a dedicated mixer for the signal to be recorded by the loopers (mic + pre-FX)
        this.recordingSourceMixer = this.audioCtx.createGain();
        
        // Mic source initially connects to the pre-FX chain
        // The last node of the Pre-FX chain connects to recordingSourceMixer
        // The mic input is also directly monitored via the monitorGain
        this.micSource.connect(this.recordingSourceMixer); // Initial connection, overridden by Pre-FX setup
        
        this.liveMicMonitorGain = this.audioCtx.createGain();
        this.liveMicMonitorGain.gain.value = 0;
        this.recordingSourceMixer.connect(this.liveMicMonitorGain);
        this.liveMicMonitorGain.connect(this.audioCtx.destination);
    }

    startRecording(looper) {
        if (!this.recorder || this.activeRecorderLooper) return;
        if (looper.index >= 2 && !this.masterIsSet) return;

        this.activeRecorderLooper = looper;
        looper.state = 'recording';
        looper.updateUI();

        if (looper.index === 1) {
            looper.animateMasterInitialRecording(60000);
        }

        this.recorder.start();
    }

    stopRecording(looper) {
        if (looper.state !== 'recording' || this.activeRecorderLooper !== looper) return;
        if (looper.index === 1) cancelAnimationFrame(looper.animationFrameId);
        if (this.recorder) this.recorder.stop();
    }

    abortRecording(looper) {
        if (looper.state !== 'recording' || this.activeRecorderLooper !== looper) {
            return;
        }
        
        if (looper.index === 1) {
            cancelAnimationFrame(looper.animationFrameId);
        }
        
        this.activeRecorderLooper = null; 
        
        if (this.recorder) {
            this.recorder.stop();
        }
        
        looper.state = 'ready';
        looper.updateUI();
    }

    async runLatencyCalibration() {
        if (this.isCalibrating) return;
        this.isCalibrating = true;

        await this.ensureMic();

        this.showMsg("Starting calibration (2 beeps)... Silence, please.", "#38b6ff");
        const caliBtn = this.$('#calibrateBtn');
        if (caliBtn) caliBtn.disabled = true;
        
        // --- CALIBRATION PARAMETERS ---
        const TARGET_INTERVAL_S = 0.5;       // Time difference between generated beeps (0.5s)
        const BEEP_DURATION = 0.05;          // 50ms pulse
        const INITIAL_WAIT_S = 0.3;          // Initial silence before first beep starts
        const RECORD_DURATION_S = INITIAL_WAIT_S + TARGET_INTERVAL_S + BEEP_DURATION + 0.3; // ~1.15s
        
        const sr = this.audioCtx.sampleRate;
        const PEAK_SCAN_WINDOW = Math.round(0.01 * sr); // 10ms window to confirm a peak
        
        let audioDataBuffer = []; // Array to store all incoming audio blocks
        let detectedPeaks = []; // Stores the sample index where a peak occurred
        
        this.recorder.ondata = (channels) => {
            if (this.isCalibrating) {
                // Store the current audio block data for post-processing
                audioDataBuffer.push(channels[0].slice());
            }
        };

        this.recorder.start();
        const recordingStartTime = this.audioCtx.currentTime;

        // 1. Setup Oscillator and Gain Nodes
        const osc1 = this.audioCtx.createOscillator();
        const osc2 = this.audioCtx.createOscillator();
        const gain = this.audioCtx.createGain();

        // 2. Schedule Beeps
        const BEEP_1_TIME = recordingStartTime + INITIAL_WAIT_S; // First beep start time (0.3s into recording)
        const BEEP_2_TIME = BEEP_1_TIME + TARGET_INTERVAL_S; // Second beep start time
        
        osc1.type = 'sine'; osc1.frequency.setValueAtTime(880, BEEP_1_TIME);
        osc2.type = 'sine'; osc2.frequency.setValueAtTime(440, BEEP_2_TIME); 
        
        // Gain automation for Beep 1
        gain.gain.setValueAtTime(0, 0);
        // INCREASED GAIN HERE (from 1.0 to 2.5)
        gain.gain.linearRampToValueAtTime(2.5, BEEP_1_TIME);
        gain.gain.linearRampToValueAtTime(0.0, BEEP_1_TIME + BEEP_DURATION);
        
        // Gain automation for Beep 2
        gain.gain.setValueAtTime(0.0, BEEP_2_TIME - 0.01); // Ensure gain is zero before second beat starts
        // INCREASED GAIN HERE (from 1.0 to 2.5)
        gain.gain.linearRampToValueAtTime(2.5, BEEP_2_TIME);
        gain.gain.linearRampToValueAtTime(0.0, BEEP_2_TIME + BEEP_DURATION);
        
        // 3. Connect and Start
        osc1.connect(gain); osc2.connect(gain);
        gain.connect(this.audioCtx.destination);
        osc1.start(BEEP_1_TIME); osc2.start(BEEP_2_TIME);
        osc1.stop(BEEP_1_TIME + BEEP_DURATION + 0.1);
        osc2.stop(BEEP_2_TIME + BEEP_DURATION + 0.1);

        // 4. Stop recording after the total duration
        setTimeout(() => {
            this.recorder.stop();
            
            // --- PEAK DETECTION & CALCULATION ---
            let combinedData = new Float32Array(audioDataBuffer.reduce((acc, arr) => acc + arr.length, 0));
            let offset = 0;
            audioDataBuffer.forEach(arr => {
                combinedData.set(arr, offset);
                offset += arr.length;
            });
            
            // 4a. Find the two absolute peaks in the expected time windows
            
            /**
             * Finds the index of the largest absolute value within a sample window.
             * @param {Float32Array} data - The audio data.
             * @param {number} startS - Start time in seconds (relative to audio data start/recording start).
             * @param {number} endS - End time in seconds.
             * @returns {number} The sample index of the peak, or -1 if no peak found.
             */
            const findAbsolutePeakIndex = (data, startS, endS) => {
                const startIdx = Math.max(0, Math.floor(startS * sr));
                const endIdx = Math.min(data.length, Math.floor(endS * sr));
                let maxVal = 0;
                let maxIdx = -1;
                
                for (let i = startIdx; i < endIdx; i++) {
                    const absVal = Math.abs(data[i]);
                    if (absVal > maxVal) {
                        maxVal = absVal;
                        maxIdx = i;
                    }
                }
                return maxIdx;
            };

            // Define search windows (generous allowance for device input/output lag)
            const SEARCH_WINDOW_PADDING = 0.150; // Search 150ms before/after target time
            
            // Calculate expected audio times (relative to recording start time = 0)
            const BEEP_1_TARGET_MID_S = INITIAL_WAIT_S + (BEEP_DURATION / 2); // Expected peak time ~0.325s
            const BEEP_2_TARGET_MID_S = BEEP_1_TARGET_MID_S + TARGET_INTERVAL_S; // Expected peak time ~0.825s

            // Window 1: Look around BEEP_1_TARGET_MID_S
            const p1Idx = findAbsolutePeakIndex(combinedData, 
                BEEP_1_TARGET_MID_S - SEARCH_WINDOW_PADDING,
                BEEP_1_TARGET_MID_S + SEARCH_WINDOW_PADDING
            );

            // Window 2: Look around BEEP_2_TARGET_MID_S
            const p2Idx = findAbsolutePeakIndex(combinedData, 
                BEEP_2_TARGET_MID_S - SEARCH_WINDOW_PADDING,
                BEEP_2_TARGET_MID_S + SEARCH_WINDOW_PADDING
            );
            
            detectedPeaks = [p1Idx, p2Idx].filter(idx => idx > -1);

            // 4b. Final Calculation
            let resultEl = this.$('#calibrationResult');
            
            // Crucial checks: Must find 2 peaks, and the second peak must occur after the first.
            if (detectedPeaks.length >= 2 && p1Idx < p2Idx) {
                
                const t1PeakTimeS = p1Idx / sr;
                
                // --- Primary Calculation: Round-Trip Latency ---
                // Latency = Recorded Peak Time - Emitted Target Time
                const rawRoundTripLatencyS = t1PeakTimeS - BEEP_1_TARGET_MID_S;
                const nudgeMs = -Math.round(rawRoundTripLatencyS * 1000); // Nudge value is inverse of latency

                // --- Secondary Calculation: Jitter Check (Interval stability) ---
                const detectedIntervalS = (p2Idx - p1Idx) / sr; 
                const intervalShiftS = detectedIntervalS - TARGET_INTERVAL_S;
                const jitterMs = Math.abs(intervalShiftS * 1000);
                
                if (jitterMs > 50) {
                     this.showMsg(`Calibration Failed (High Jitter: ${jitterMs.toFixed(1)}ms). Try a quieter environment.`, "#f43f5e");
                     if (resultEl) resultEl.textContent = 'Result: Jitter Failed';
                } else {
                     this.showMsg(`Calibration Success! Nudge set to ${nudgeMs}ms.`, "#21f7a8");
                     if (resultEl) resultEl.textContent = `Result: ${nudgeMs} ms`;

                     const nudgeSlider = this.$('#nudgeMs');
                     const nudgeVal = this.$('#nudgeVal');
                     if (nudgeSlider && nudgeVal) {
                         nudgeSlider.value = nudgeMs;
                         nudgeVal.textContent = nudgeMs;
                         this.loopers.forEach(l => { if (l) l.manualNudgeMs = nudgeMs; });
                     }
                }
            } else {
                this.showMsg(`Calibration failed. Could only detect ${detectedPeaks.length} clear peaks.`, "#f43f5e");
                if (resultEl) resultEl.textContent = 'Result: Failed';
            }

            if (caliBtn) caliBtn.disabled = false;
            this.isCalibrating = false;
            this.recorder.ondata = this.handleWorkletData.bind(this); // Restore default handler
        }, RECORD_DURATION_S * 1000); 
    }

    handleWorkletData(channels, marks) {
        const overdubbingLooper = this.loopers.find(lp => lp && ['overdub', 'prerecord'].includes(lp.state));

        if (overdubbingLooper) {
            const active = overdubbingLooper;
            let recorded = channels[0] || new Float32Array(0);
            const mark = marks.length > 0 ? marks[0] : 0;
            if (mark > 0 && mark < recorded.length) {
                recorded = recorded.slice(mark);
            }

            if (!active.loopBuffer || recorded.length === 0) {
                active.state = 'playing';
                active.updateUI();
                return;
            }

            const sr = active.loopBuffer.sampleRate;
            const masterLen = active.loopBuffer.length;
            const outC = active.loopBuffer.numberOfChannels;

            const nudgeSamples = Math.round((active.manualNudgeMs || 0) / 1000 * sr);
            let startSample = nudgeSamples;

            const out = this.audioCtx.createBuffer(outC, masterLen, sr);
            for (let ch = 0; ch < outC; ch++) out.getChannelData(ch).set(active.loopBuffer.getChannelData(ch));

            for (let i = 0; i < recorded.length; i++) {
                let writeIdx = (startSample + i) % masterLen;
                if (writeIdx < 0) writeIdx += masterLen;
                if (writeIdx < masterLen) {
                    for (let ch = 0; ch < outC; ch++) {
                        out.getChannelData(ch)[writeIdx] += recorded[i] * (active.overdubGain || 1.0);
                    }
                }
            }

            for (let ch = 0; ch < out.numberOfChannels; ch++) {
                const d = out.getChannelData(ch);
                for (let i = 0; i < d.length; i++) d[i] = this.clamp(d[i], -1, 1);
            }
            active.loopBuffer = out;
            active.state = 'playing';
            active.updateUI();
            active.startPlayback();

        } else if (this.activeRecorderLooper) {
            const looper = this.activeRecorderLooper;
            this.activeRecorderLooper = null;

            if (channels.length === 0 || channels[0].length === 0) {
                looper.state = 'ready';
                looper.updateUI();
                return;
            }

            const sr = this.audioCtx.sampleRate;

            if (looper.index > 1 && this.masterIsSet) {
                const masterLenSamples = Math.round(this.masterLoopDuration * looper.divider * sr);
                const newBuffer = this.audioCtx.createBuffer(channels.length, masterLenSamples, sr);
                
                const nudgeSamples = Math.round((looper.manualNudgeMs || 0) / 1000 * sr);

                for (let ch = 0; ch < newBuffer.numberOfChannels; ch++) {
                    const outputData = newBuffer.getChannelData(ch);
                    const inputData = channels[ch] || channels[0];
                    
                    for (let i = 0; i < inputData.length; i++) {
                        let writeIdx = (nudgeSamples + i) % masterLenSamples;
                        if (writeIdx < 0) writeIdx += masterLenSamples;
                        
                        if (writeIdx < masterLenSamples) {
                            outputData[writeIdx] = inputData[i];
                        }
                    }
                }
                
                looper.loopBuffer = newBuffer;
                looper.loopDuration = newBuffer.duration;

            } else {
                const bufferLength = channels[0].length;
                const newBuffer = this.audioCtx.createBuffer(channels.length, bufferLength, sr);
                for (let i = 0; i < channels.length; i++) {
                    newBuffer.getChannelData(i).set(channels[i]);
                }

                looper.loopBuffer = newBuffer;
                looper.loopDuration = newBuffer.duration;
            }

            if (looper.index === 1) {
                this.masterLoopDuration = looper.loopDuration;
                this.masterBPM = Math.round((60 / looper.loopDuration) * 4);
                this.masterIsSet = true;
                this.$('#bpmLabel').textContent = `BPM: ${this.masterBPM}`;
                if (this.onBpmUpdate) this.onBpmUpdate();
                for (let k = 2; k <= this.looperCount; k++) {
                    if (this.loopers[k]) this.loopers[k].disable(false);
                }
                if (!this.globalAnimationId && this.onFirstLoopCallback) {
                    this.onFirstLoopCallback();
                }
            }
            looper.state = 'playing';
            looper.updateUI();
            looper.startPlayback();
        }
    }
}


// Part 3: Main Application Logic
document.addEventListener('DOMContentLoaded', () => {

    const engine = new LooperEngine();
    let audioCtx = engine.audioCtx;
    let preFxViz = null; // Visualizer instance

    // --- Pre-Loop FX Nodes & Chain ---
    let preFxNodes = {
        reverb: { node: null, wet: null, params: { mix: 0.25, roomSeconds: 2.5, decay: 2.0, preDelayMs: 20 } },
        delay: { node: null, wet: null, feedback: null, params: { mix: 0.25, feedbackAmt: 0.35, syncMode: 'note', division: '1/8', variant: 'straight', delayMs: 250 } },
        phaser: { nodes: [], wet: null, params: { mix: 0.4, rateHz: 0.5, depth: 0.6, stages: 4, baseFreq: 350 } },
        // Remaining FX parameters are kept in memory for persistence
        compressor: { node: null, wet: null, params: { mix: 0.5, threshold: -24, knee: 30, ratio: 12, attack: 0.003, release: 0.25 } },
        distortion: { node: null, wet: null, params: { mix: 0.3, amount: 100 } },
        eq5: { node: null, wet: null, params: { mix: 1.0, lowGain: 3, midGain: 2, midFreq: 1200, midQ: 0.9, highGain: 3 } },
    };
    
    // The main Pre-FX Chain (dynamic and reorderable)
    let preFxChain = [
        { id: 1, type: 'reverb', name: 'Reverb', bypass: false, nodeKey: 'reverb' },
        { id: 2, type: 'delay', name: 'Delay', bypass: false, nodeKey: 'delay' },
        { id: 3, type: 'phaser', name: 'Phaser', bypass: false, nodeKey: 'phaser' }
    ];
    let preFxNextId = 4;
    
    // COMBINED FX ASSIGNMENTS (4 slots total)
    // Each assignment holds: { looperIndex, fxId, param, popupSliderId, isAutomationActive, points, min, max, type }
    let fxAssignments = [null, null, null, null];
    let linkingState = { active: false, looperIndex: null, fxId: null, param: null, sourceElement: null, popupSliderId: null };
    
    // --- Volume Preset Data (UPDATED STRUCTURE) ---
    let volumePresets = [
        { name: 'Preset 1', settings: {} },
        { name: 'Preset 2', settings: {} },
        { name: 'Preset 3', settings: {} },
        { name: 'Preset 4', settings: {} }
    ];
    let activePresetTimeChain = {}; // {trackId: {startTime, duration, points}}


    const $ = s => document.querySelector(s);
    const bpmLabel = $('#bpmLabel');
    const fxMenuPopup = $('#fxMenuPopup');
    const fxParamsPopup = $('#fxParamsPopup');
    const preFxManagementPopup = $('#preFxManagementPopup');
    const macroManagementPopup = $('#macroManagementPopup'); // NEW
    const volumeGraphPopup = $('#volumeGraphPopup');

    const addTap = (btn, fn) => { if (!btn) return; btn.addEventListener('click', fn); };
    function addHold(btn, onHold, onTap, holdDuration = 1500) {
        if (!btn) return;
        let timer;
        let isHeld = false;
        const start = (e) => { e.preventDefault(); isHeld = false; timer = setTimeout(() => { isHeld = true; onHold(e); }, holdDuration); };
        const end = (e) => { e.preventDefault(); clearTimeout(timer); if (!isHeld) { onTap(e); } };
        btn.addEventListener('mousedown', start);
        btn.addEventListener('touchstart', start, { passive: false });
        ['mouseup', 'mouseleave', 'touchend', 'touchcancel'].forEach(ev => btn.addEventListener(ev, end, { passive: false }));
    };
    function debounce(fn, ms = 130) { let t; return (...a) => { clearTimeout(t); t = setTimeout(() => fn(...a), ms); }; }
    
    const PRE_FX_CATALOG = [
        { type:'reverb', name:'Reverb', params:{ mix: 0.25, roomSeconds: 2.5, decay: 2.0, preDelayMs: 20 } },
        { type:'delay', name:'Delay', params:{ mix: 0.25, feedbackAmt: 0.35, syncMode: 'note', division: '1/8', variant: 'straight', delayMs: 250 } },
        { type:'phaser', name:'Phaser', params:{ mix: 0.4, rateHz: 0.5, depth: 0.6, stages: 4, baseFreq: 350 } },
        { type:'compressor', name:'Compressor', params: { mix: 0.5, threshold: -24, knee: 30, ratio: 12, attack: 0.003, release: 0.25 } },
        { type:'distortion', name:'Distortion', params: { mix: 0.3, amount: 100 } },
        { type:'eq5', name:'EQ (5 Band)', params: { mix: 1.0, lowGain: 3, midGain: 2, midFreq: 1200, midQ: 0.9, highGain: 3 } }
    ];
    
    function makeDistortionCurve(amount) {
        const k = typeof amount === 'number' ? amount : 50;
        const n_samples = 44100;
        const curve = new Float32Array(n_samples);
        const deg = Math.PI / 180;
        for (let i = 0; i < n_samples; ++i) {
            const x = i * 2 / n_samples - 1;
            curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
    }

    function makeReverbImpulse(seconds, decay){
        const sr = audioCtx.sampleRate, len = Math.max(1, Math.floor(sr*seconds));
        const buf = audioCtx.createBuffer(2, len, sr);
        for (let ch=0; ch<2; ch++){
            const d = buf.getChannelData(ch);
            for (let i=0;i<len;i++){
            const t = i/len;
            d[i] = (Math.random()*2-1) * Math.pow(1 - t, decay);
            }
        }
        return buf;
    }

    function buildPhaser(params) {
        let phaserNodes = [];
        let prevNode = null;
        for (let i = 0; i < params.stages; i++) {
            const allpass = audioCtx.createBiquadFilter();
            allpass.type = 'allpass';
            phaserNodes.push(allpass);
            if (prevNode) {
                prevNode.connect(allpass);
            }
            prevNode = allpass;
        }
        
        const lfo = audioCtx.createOscillator();
        lfo.type = 'sine';
        const depth = audioCtx.createGain();
        
        lfo.connect(depth);
        phaserNodes.forEach(node => depth.connect(node.frequency));
        
        // Initial parameter setup
        lfo.frequency.value = params.rateHz;
        depth.gain.value = params.baseFreq * params.depth;
        phaserNodes.forEach((node, i) => node.frequency.value = params.baseFreq * Math.pow(2, i));

        lfo.start();
        return { nodes: phaserNodes, lfo, depth };
    }

    const NOTE_MULT = { '1/1':4, '1/2':2, '1/4':1, '1/8':0.5, '1/16':0.25, '1/32':0.125 };
    function quarterSecForBPM(bpm){ return 60/(bpm||120); }
    function applyVariant(mult, v){ return v==='dotted' ? mult*1.5 : v==='triplet' ? mult*(2/3) : mult; }

    function updateDelayTime(params){
      if (params.syncMode !== 'note') return;
      const q = quarterSecForBPM(engine.masterBPM || 120);
      const mult = applyVariant(NOTE_MULT[params.division]||0.5, params.variant);
      return engine.clamp(q*mult, 0.001, 2.0);
    }
    
    // --- Core Pre-FX Graph Logic ---
    function setupPreLoopFxGraph() {
        if (!engine.micSource) return;

        // 1. Disconnect everything from micSource and output nodes to prevent double connections
        try { engine.micSource.disconnect(); } catch {}
        try { engine.dryGain.disconnect(); } catch {}
        try { engine.fxSumGain.disconnect(); } catch {}

        // Disconnect and clean up old Pre-FX AudioNodes
        for (const key in preFxNodes) {
             const fx = preFxNodes[key];
             if (fx.lfo && fx.lfo.stop) { try{ fx.lfo.stop(); } catch{} }
             // We'll manage just the explicit nodes we created.
             if (fx.node && fx.node.disconnect) { try{ fx.node.disconnect(); } catch{} }
             if (fx.delay && fx.delay.disconnect) { try{ fx.delay.disconnect(); } catch{} }
             if (fx.feedback && fx.feedback.disconnect) { try{ fx.feedback.disconnect(); } catch{} }
             if (fx.nodes) { fx.nodes.forEach(n => { try { n.disconnect(); } catch {} }); }

             // Clear nodes/references for rebuilding
             fx.node = null; fx.wet = null; fx.dry = null; fx.feedback = null; fx.lfo = null; fx.nodes = [];
        }


        // 2. Initialize Nodes
        preFxChain.forEach(fx => {
            const params = preFxNodes[fx.type].params;
            const fxData = preFxNodes[fx.type];
            
            if (fx.type === 'reverb') {
                fxData.node = audioCtx.createConvolver(); fxData.node.normalize = true;
                fxData.delay = audioCtx.createDelay(1.0);
                fxData.wet = audioCtx.createGain(); fxData.dry = audioCtx.createGain();
                fxData.node.buffer = makeReverbImpulse(params.roomSeconds, params.decay);
                fxData.delay.delayTime.value = params.preDelayMs / 1000;
            } else if (fx.type === 'delay') {
                fxData.node = audioCtx.createDelay(2.0);
                fxData.feedback = audioCtx.createGain();
                fxData.wet = audioCtx.createGain(); fxData.dry = audioCtx.createGain();
                fxData.node.delayTime.value = updateDelayTime(params);
            } else if (fx.type === 'phaser') {
                const { nodes, lfo, depth } = buildPhaser(params);
                fxData.nodes = nodes; fxData.lfo = lfo; fxData.depth = depth;
                fxData.wet = audioCtx.createGain(); fxData.dry = audioCtx.createGain();
            } else if (fx.type === 'compressor') {
                fxData.node = audioCtx.createDynamicsCompressor();
                fxData.wet = audioCtx.createGain(); fxData.dry = audioCtx.createGain();
                fxData.node.threshold.value = params.threshold; fxData.node.ratio.value = params.ratio;
                fxData.node.knee.value = params.knee; fxData.node.attack.value = params.attack; fxData.node.release.value = params.release;
            } else if (fx.type === 'distortion') {
                fxData.node = audioCtx.createWaveShaper(); fxData.node.oversample = '4x';
                fxData.node.curve = makeDistortionCurve(params.amount);
                fxData.wet = audioCtx.createGain(); fxData.dry = audioCtx.createGain();
            } else if (fx.type === 'eq5') {
                 fxData.low = audioCtx.createBiquadFilter(); fxData.mid = audioCtx.createBiquadFilter(); fxData.high = audioCtx.createBiquadFilter();
                 fxData.low.type='lowshelf'; fxData.low.frequency.value=180; fxData.low.gain.value=params.lowGain;
                 fxData.mid.type='peaking';  fxData.mid.frequency.value=params.midFreq; fxData.mid.Q.value=params.midQ; fxData.mid.gain.value=params.midGain;
                 fxData.high.type='highshelf'; fxData.high.frequency.value=4500; fxData.high.gain.value=params.highGain;
            }
        });
        
        // 3. Wire the Chain and Set Mix
        let dryChainHead = engine.micSource; // Head of the Dry/Through signal path
        
        preFxChain.forEach(fx => {
            const fxData = preFxNodes[fx.type];
            const params = fxData.params;
            
            // Bypass state check
            const isBypassed = fx.bypass;

            // Set Mix for effects that have it (Wet gain controls wet signal, Dry is 1.0 or modified by EQ)
            if (fxData.wet) {
                fxData.wet.gain.value = isBypassed ? 0 : params.mix;
                fxData.dry.gain.value = 1.0; // Dry signal is passed through, its gain is 1.0
            }
            
            // --- Wire the specific effect type ---
            if (fx.type === 'reverb') {
                // Dry through: dryChainHead -> dry -> new dryChainHead (unless bypassed)
                // Wet path: dryChainHead -> delay -> convolver -> wet -> fxSumGain
                dryChainHead.connect(fxData.dry); fxData.dry.connect(engine.dryGain); 
                dryChainHead.connect(fxData.delay); fxData.delay.connect(fxData.node);
                fxData.node.connect(fxData.wet); fxData.wet.connect(engine.fxSumGain);
                dryChainHead = fxData.dry;
            } else if (fx.type === 'delay') {
                // Dry through: dryChainHead -> dry -> new dryChainHead
                // Wet path: dryChainHead -> delay -> feedback loop -> delay -> wet -> fxSumGain
                dryChainHead.connect(fxData.dry); fxData.dry.connect(engine.dryGain); 
                dryChainHead.connect(fxData.node); fxData.node.connect(fxData.feedback); 
                fxData.feedback.gain.value = isBypassed ? 0 : params.feedbackAmt;
                fxData.feedback.connect(fxData.node); fxData.node.connect(fxData.wet); 
                fxData.wet.connect(engine.fxSumGain);
                dryChainHead = fxData.dry;
            } else if (fx.type === 'phaser') {
                // Dry through: dryChainHead -> dry -> new dryChainHead
                // Wet path: dryChainHead -> Phaser Chain (nodes[0]) -> nodes[n-1] -> wet -> fxSumGain
                dryChainHead.connect(fxData.dry); fxData.dry.connect(engine.dryGain); 
                dryChainHead.connect(fxData.nodes[0]); 
                fxData.nodes[fxData.nodes.length-1].connect(fxData.wet); 
                fxData.wet.connect(engine.fxSumGain);
                dryChainHead = fxData.dry;
            } else if (fx.type === 'compressor' || fx.type === 'distortion') {
                // Dry through: dryChainHead -> dry -> new dryChainHead
                // Wet path: dryChainHead -> node -> wet -> fxSumGain
                dryChainHead.connect(fxData.dry); fxData.dry.connect(engine.dryGain); 
                dryChainHead.connect(fxData.node); fxData.node.connect(fxData.wet); 
                fxData.wet.connect(engine.fxSumGain);
                dryChainHead = fxData.dry;
            } else if (fx.type === 'eq5') {
                 // EQ entirely replaces the signal path. We disconnect the previous head from dryGain
                 // and reconnect the EQ chain to dryGain.
                 if (!isBypassed) {
                     dryChainHead.disconnect(engine.dryGain);
                     dryChainHead.connect(fxData.low); fxData.low.connect(fxData.mid); 
                     fxData.mid.connect(fxData.high); fxData.high.connect(engine.dryGain);
                     dryChainHead = fxData.high; // Next effect connects from the EQ output
                 } else {
                     // If EQ is bypassed, reconnect the previous head directly to the final dry output
                     dryChainHead.connect(engine.dryGain);
                 }
            }
        });
        
        // 4. Final routing (Already done inside the loop, but needed for the initial empty chain case)
        if (preFxChain.length === 0) {
            engine.micSource.connect(engine.dryGain);
        }
        
        // The final mix of dry (through chain/EQ) and wet (from fxSumGain) goes to recording mixer/monitor
        engine.dryGain.connect(engine.recordingSourceMixer);
        engine.fxSumGain.connect(engine.recordingSourceMixer);
        
        // Update the visualizer connection
        const vizCanvas = $('#preFxVisualizer');
        if (vizCanvas && typeof AudioVisualizer !== 'undefined') {
             if (preFxViz) { try { preFxViz.disconnect(); } catch {} }
             // The visualizer expects an AudioNode to connect from.
             // We'll connect it from the recordingSourceMixer which holds the combined mic + pre-FX signal.
             if (engine.recordingSourceMixer) {
                 preFxViz = new AudioVisualizer(engine.audioCtx, engine.recordingSourceMixer, vizCanvas);
             }
        }

        renderPreFxList();
    }
    
    // Moved outside initializeApp to resolve ReferenceError
    function createLooperHTML(index) {
        const colors = ['#fde047', '#34d399', '#fb923c', '#a78bfa', '#f472b6'];
        const color = colors[(index - 4 + colors.length) % colors.length];
        // Note: The delete button is included in this template
        return `<div class="pedal-unit looper-pedal" id="looper${index}" style="border-top-color: ${color};"> <button class="delete-track-btn" data-track-id="${index}">‚úï</button><div class="track-label">TRACK ${index}</div> <div class="display-area"> <svg class="progress-ring"><circle id="progressBar${index}" r="46" cx="50" cy="50" style="stroke: ${color}"/></svg> <div class="looper-icon" id="looperIcon${index}">‚ñ∂</div> </div> <div class="state-display" id="stateDisplay${index}">Ready</div> <div class="controls-area"> <label class="looper-vol-label"><span>Vol</span><input type="range" class="looper-vol-slider" id="volSlider${index}" value="90" min="0" max="120"/><span id="volValue${index}">90%</span></label> <div class="track-fx-labels" id="trackFxLabels${index}"></div> <select id="divider${index}"><option value="1">x1</option><option value="0.5">x¬Ω</option><option value="2">x2</option></select> </div> <div class="button-grid"> <button class="btn main-looper-btn" id="mainLooperBtn${index}">Record</button> <button class="btn stop-btn" id="stopBtn${index}">Stop/Clear</button> <button class="btn fx-menu-btn" id="fxMenuBtn${index}">üéõ FX Menu</button> </div> </div>`;
    }

    // --- Pre-FX UI and Management Functions (GLOBALIZED) ---
    function renderPreFxList() {
        const listEl = $('#preFxList');
        if (!listEl) return;
        listEl.innerHTML = preFxChain.map((fx, index) => `
            <li data-id="${fx.id}" data-index="${index}" class="${fx.bypass ? 'bypassed' : 'active'}">
                <span class="fx-name">${fx.name}</span>
                <span class="fx-controls">
                    <button class="btn-up" data-id="${fx.id}" ${index === 0 ? 'disabled' : ''}>‚Üë</button>
                    <button class="btn-down" data-id="${fx.id}" ${index === preFxChain.length - 1 ? 'disabled' : ''}>‚Üì</button>
                    <button class="btn-edit" data-id="${fx.id}">Edit</button>
                    <button class="btn-bypass" data-id="${fx.id}">${fx.bypass ? 'OFF' : 'ON'}</button>
                    <button class="btn-remove" data-id="${fx.id}">‚úï</button>
                </span>
            </li>
        `).join('');

        listEl.querySelectorAll('.btn-up').forEach(b=>b.addEventListener('click', ()=>movePreFx(parseInt(b.dataset.id), -1)));
        listEl.querySelectorAll('.btn-down').forEach(b=>b.addEventListener('click', ()=>movePreFx(parseInt(b.dataset.id), 1)));
        listEl.querySelectorAll('.btn-edit').forEach(b=>b.addEventListener('click', ()=>openPreFxParams(parseInt(b.dataset.id))));
        listEl.querySelectorAll('.btn-bypass').forEach(b=>b.addEventListener('click', ()=>togglePreFxBypass(parseInt(b.dataset.id))));
        listEl.querySelectorAll('.btn-remove').forEach(b=>b.addEventListener('click', ()=>removePreFx(parseInt(b.dataset.id))));
    }
    
    function movePreFx(fxId, dir) {
        const idx = preFxChain.findIndex(e=>e.id===fxId);
        if (idx === -1) return;
        if ((dir === -1 && idx === 0) || (dir === 1 && idx === preFxChain.length - 1)) return;
        
        [preFxChain[idx], preFxChain[idx + dir]] = [preFxChain[idx + dir], preFxChain[idx]];
        updatePreFxGraph();
            initCombinedFxControls(); // CORRECTED: Should call initCombinedFxControls on structure change
    }

    function removePreFx(fxId) {
        preFxChain = preFxChain.filter(e => e.id !== fxId);
        updatePreFxGraph();
    }
    
    function addPreFx(fxType) {
        const template = PRE_FX_CATALOG.find(e => e.type === fxType);
        if (!template) return;
        
        const newFx = { 
            id: preFxNextId++, 
            type: fxType, 
            name: template.name, 
            bypass: false 
        };
        
        // If the FX is new, ensure its parameter object is cloned/initialized
        if (!preFxNodes[fxType].params) {
            preFxNodes[fxType].params = { ...template.params };
        }
        
        preFxChain.push(newFx);
        updatePreFxGraph();
        openPreFxParams(newFx.id);
    }
    
    function togglePreFxBypass(fxId) {
        const fx = preFxChain.find(e => e.id === fxId);
        if (!fx) return;
        fx.bypass = !fx.bypass;
        updatePreFxGraph();
    }
    
    function openPreFxMenu() {
        preFxManagementPopup.classList.remove('hidden');
        preFxManagementPopup.innerHTML = `<div class="fx-popup-inner">
            <h3>Add Pre-Loop Effects</h3>
            <label>Select Effect: 
                <select id="addPreFxSelect" style="width: 150px;">
                    <option value="">--Select--</option>
                    ${PRE_FX_CATALOG.map(fx => `<option value="${fx.type}">${fx.name}</option>`).join('')}
                </select>
            </label>
            <button id="addPreFxBtn">Add to Chain</button>
            <button id="closePreFxMenu" class="stop-btn">Close</button>
        </div>`;
        
        $('#addPreFxBtn').addEventListener('click', () => { 
            const type = $('#addPreFxSelect').value; 
            if (type) {
                addPreFx(type);
                preFxManagementPopup.classList.add('hidden');
            }
        });
        $('#closePreFxMenu').addEventListener('click',() => preFxManagementPopup.classList.add('hidden'));
    }
    
    function openPreFxParams(fxId){
        const fxEntry = preFxChain.find(e=>e.id===fxId);
        if (!fxEntry) return;
        const fxData = preFxNodes[fxEntry.type];
        let params = fxData.params;
        
        fxParamsPopup.classList.remove('hidden');
        fxParamsPopup.innerHTML = `<div class="fx-popup-inner">
            <h3>Edit: ${fxEntry.name} Parameters</h3>
            <div id="preFxParamsBody">${renderPreFxParamsHtml(fxEntry.type, params)}</div>
            <button id="closeFxParams">Close</button>
        </div>`;
        
        $('#closeFxParams').addEventListener('click', ()=>fxParamsPopup.classList.add('hidden'));
        wirePreFxParams(fxEntry.type, params, fxData);
    }

    function renderPreFxParamsHtml(fxType, params) {
        const p = params;
        const paramToHtml = (param, name, min, max, step, val, displayFn = v => v.toFixed(param.match(/mix|q|depth|feedback/) ? 2 : 0)) => {
            return `<label><span>${name} <span id="${param}Val">${displayFn(val)}</span></span> <div><input id="${param}" type="range" min="${min}" max="${max}" step="${step}" value="${val}"></div></label>`;
        };
        const selectToHtml = (param, name, options, val) => {
            const optionsHtml = options.map(o => `<option value="${o}" ${o === val ? 'selected' : ''}>${o}</option>`).join('');
            return `<label><span>${name}</span> <div><select id="${param}">${optionsHtml}</select></div></label>`;
        };
        
        let html = '';
        if (fxType === 'reverb') {
            html += paramToHtml('mix', 'Mix', 0, 1, 0.01, p.mix, v => `${(v*100).toFixed(0)}%`);
            html += paramToHtml('roomSeconds', 'Room Size', 0.3, 6.0, 0.05, p.roomSeconds, v => `${v.toFixed(2)} s`);
            html += paramToHtml('decay', 'Decay', 0.5, 4.0, 0.05, p.decay, v => v.toFixed(2));
            html += paramToHtml('preDelayMs', 'Pre-delay', 0, 200, 1, p.preDelayMs, v => `${v} ms`);
        } else if (fxType === 'delay') {
            html += paramToHtml('mix', 'Mix', 0, 1, 0.01, p.mix, v => `${(v*100).toFixed(0)}%`);
            html += paramToHtml('feedbackAmt', 'Feedback', 0, 0.95, 0.01, p.feedbackAmt, v => `${(v*100).toFixed(0)}%`);
            html += selectToHtml('division', 'Division', ['1/1','1/2','1/4','1/8','1/16','1/32'], p.division);
            html += selectToHtml('variant', 'Variant', ['straight', 'dotted', 'triplet'], p.variant);
        } else if (fxType === 'phaser') {
            html += paramToHtml('mix', 'Mix', 0, 1, 0.01, p.mix, v => `${(v*100).toFixed(0)}%`);
            html += paramToHtml('rateHz', 'Rate', 0.05, 5, 0.01, p.rateHz, v => `${v.toFixed(2)} Hz`);
            html += paramToHtml('depth', 'Depth', 0, 1, 0.01, p.depth, v => v.toFixed(2));
            html += paramToHtml('baseFreq', 'Base Freq', 20, 2000, 10, p.baseFreq, v => `${v} Hz`);
            html += paramToHtml('stages', 'Stages', 2, 12, 2, p.stages, v => v.toFixed(0));
        } else if (fxType === 'compressor') {
            html += paramToHtml('mix', 'Mix', 0, 1, 0.01, p.mix, v => `${(v*100).toFixed(0)}%`);
            html += paramToHtml('threshold', 'Threshold', -100, 0, 1, p.threshold, v => `${v.toFixed(0)} dB`);
            html += paramToHtml('ratio', 'Ratio', 1, 20, 1, p.ratio, v => `${v.toFixed(0)}:1`);
            html += paramToHtml('knee', 'Knee', 0, 40, 1, p.knee, v => v.toFixed(0));
            html += paramToHtml('attack', 'Attack', 0, 1, 0.001, p.attack, v => `${(v * 1000).toFixed(1)} ms`);
            html += paramToHtml('release', 'Release', 0, 1, 0.01, p.release, v => `${(v * 1000).toFixed(0)} ms`);
        } else if (fxType === 'distortion') {
             html += paramToHtml('mix', 'Mix', 0, 1, 0.01, p.mix, v => `${(v*100).toFixed(0)}%`);
             html += paramToHtml('amount', 'Drive', 0, 1000, 10, p.amount, v => v.toFixed(0));
        } else if (fxType === 'eq5') {
            html += paramToHtml('lowGain', 'Low Shelf Gain', -12, 12, 1, p.lowGain, v => `${v} dB`);
            html += paramToHtml('midGain', 'Mid Gain', -12, 12, 1, p.midGain, v => `${v} dB`);
            html += paramToHtml('midFreq', 'Mid Freq', 300, 5000, 10, p.midFreq, v => `${v} Hz`);
            html += paramToHtml('midQ', 'Mid Q', 0.3, 4.0, 0.01, p.midQ, v => v.toFixed(2));
            html += paramToHtml('highGain', 'High Shelf Gain', -12, 12, 1, p.highGain, v => `${v} dB`);
        }
        return html;
    }
    
    function wirePreFxParams(fxType, params) {
        const updateAndRedraw = () => { updatePreFxGraph(); renderPreFxList(); };
        const setupSlider = (param, displayFn = v => v.toFixed(param.match(/mix|q|depth|feedback/) ? 2 : 0)) => {
            const slider = $(`#${param}`);
            const valueLabel = $(`#${param}Val`);
            if (!slider) return;
            slider.addEventListener('input', debounce(e => {
                const newValue = parseFloat(e.target.value);
                params[param] = newValue;
                if (valueLabel) valueLabel.textContent = displayFn(newValue);
                updateAndRedraw();
            }));
        };
        const setupSelector = (param) => {
            const selector = $(`#${param}`);
            if (!selector) return;
            selector.addEventListener('change', debounce(e => {
                params[param] = e.target.value;
                updateAndRedraw();
            }));
        };

        if (fxType === 'reverb') {
            setupSlider('mix', v => `${(v*100).toFixed(0)}%`); setupSlider('roomSeconds', v => `${v.toFixed(2)} s`); setupSlider('decay', v => v.toFixed(2)); setupSlider('preDelayMs', v => `${v} ms`);
        } else if (fxType === 'delay') {
            setupSlider('mix', v => `${(v*100).toFixed(0)}%`); setupSlider('feedbackAmt', v => `${(v*100).toFixed(0)}%`);
            setupSelector('division'); setupSelector('variant');
        } else if (fxType === 'phaser') {
            setupSlider('mix', v => `${(v*100).toFixed(0)}%`); setupSlider('rateHz', v => `${v.toFixed(2)} Hz`); setupSlider('depth', v => v.toFixed(2)); setupSlider('baseFreq', v => `${v} Hz`); setupSlider('stages', v => v.toFixed(0));
        } else if (fxType === 'compressor') {
            setupSlider('mix', v => `${(v*100).toFixed(0)}%`); setupSlider('threshold', v => `${v.toFixed(0)} dB`); setupSlider('ratio', v => `${v.toFixed(0)}:1`); setupSlider('knee', v => v.toFixed(0)); setupSlider('attack', v => `${(v * 1000).toFixed(1)} ms`); setupSlider('release', v => `${(v * 1000).toFixed(0)} ms`);
        } else if (fxType === 'distortion') {
            setupSlider('mix', v => `${(v*100).toFixed(0)}%`); setupSlider('amount', v => v.toFixed(0));
        } else if (fxType === 'eq5') {
            setupSlider('lowGain', v => `${v} dB`); setupSlider('midGain', v => `${v} dB`); setupSlider('midFreq', v => `${v} Hz`); setupSlider('midQ', v => v.toFixed(2)); setupSlider('highGain', v => `${v} dB`);
        }
    }
    
    function updatePreFxGraph() {
        if (!engine.micSource) return;
        setupPreLoopFxGraph();
    }
    
    // --- After FX Functions (GLOBALIZED) ---
    function renderTrackFxSummary(looperIndex){
        const looper = engine.loopers[looperIndex];
        const label = $(`#trackFxLabels${looperIndex}`);
        if (!looper || !label) return;
        label.textContent = looper.fx.chain.filter(e=>!e.bypass).map(e=>e.name).join(' ‚Üí ') || 'No FX';
    }

    function moveAfterFx(looper, fxId, dir) {
        const idx = looper.fx.chain.findIndex(e=>e.id===fxId);
        if (idx===-1 || (dir===-1 && idx===0) || (dir===1 && idx===looper.fx.chain.length-1)) return;
        [looper.fx.chain[idx], looper.fx.chain[idx+dir]] = [looper.fx.chain[idx+dir], looper.fx.chain[idx]];
        looper._rebuildChainWiring();
        renderAfterFxList(looper);
    }

    function toggleAfterFxBypass(looper, fxId){
        const fx = looper.fx.chain.find(e=>e.id===fxId);
        if (!fx) return;
        fx.bypass = !fx.bypass;
        looper._rebuildChainWiring();
        renderAfterFxList(looper);
        renderTrackFxSummary(looper.index);
    }

    function removeAfterFx(looper, fxId){
        for (let i = 0; i < fxAssignments.length; i++) {
            if (fxAssignments[i] && fxAssignments[i].fxId === fxId) {
                unassignFxControl(i);
            }
        }
        looper.fx.chain = looper.fx.chain.filter(e=>e.id!==fxId);
        looper._rebuildChainWiring();
        renderAfterFxList(looper);
        renderTrackFxSummary(looper.index);
    }
    
    const AFTER_FX_CATALOG = [
        { type:'Pitch', name:'Pitch', defaults:{ semitones:0 } },
        { type:'LowPass', name:'Filter: LowPass', defaults:{ cutoff:800, q:1 } },
        { type:'HighPass', name:'Filter: HighPass', defaults:{ cutoff:500, q:1 } },
        { type:'BandPass', name:'Filter: BandPass', defaults:{ cutoff:1000, q:2 } },
        { type:'Pan', name:'Pan', defaults:{ pan:0 } },
        { type:'Compressor', name:'Compressor', defaults:{ threshold: -24, knee: 30, ratio: 12, attack: 0.003, release: 0.25 } },
        { type:'Delay', name:'Delay', defaults:{ mix: 0.3, feedback: 0.4, division: '1/4', variant: 'straight' } },
        { type:'Tremolo', name:'Tremolo', defaults:{ rate: 5, depth: 0.8 } },
        { type:'Slicer', name:'Slicer (Gate)', defaults:{ rate: 8, depth: 1.0 } },
        { type:'BeatRepeat', name:'Beat Repeat', defaults:{ mix: 0.5, division: '1/8', repeats: 4 } },
        { type:'VinylFlick', name:'Vinyl Flick/Stop', defaults:{ duration: 0.3 } },
    ];

    function addAfterFx(looper, fxType){
        const template = AFTER_FX_CATALOG.find(e=>e.type===fxType);
        if (!template || looper.fx.chain.length >= 8) return;
        const newFx = { id:looper.fx.nextId++, type:fxType, name:template.name, params:{...template.defaults}, bypass:false, nodes:null };
        looper.fx.chain.push(newFx);
        looper._rebuildChainWiring();
        renderAfterFxList(looper);
        renderTrackFxSummary(looper.index);
    }
    
    function renderAfterFxList(looper){
        const listEl = $('#afterFxList');
        if (!listEl) return;
        listEl.innerHTML = looper.fx.chain.map(fx => `
            <li style="opacity:${fx.bypass?0.6:1}">
                <span class="fx-name">${fx.name}</span>
                <span class="fx-controls">
                    <button class="btn-up" data-id="${fx.id}">‚Üë</button>
                    <button class="btn-down" data-id="${fx.id}">‚Üì</button>
                    <button class="btn-edit" data-id="${fx.id}">Edit</button>
                    <button class="btn-bypass" data-id="${fx.id}" onclick="handleBypassClick(${looper.index}, ${fx.id})">${fx.bypass?'On':'Off'}</button>
                    <button class="btn-remove" data-id="${fx.id}">‚úï</button>
                </span>
            </li>
        `).join('');

        listEl.querySelectorAll('.btn-up').forEach(b=>b.addEventListener('click', ()=>moveAfterFx(looper, parseInt(b.dataset.id), -1)));
        listEl.querySelectorAll('.btn-down').forEach(b=>b.addEventListener('click', ()=>moveAfterFx(looper, parseInt(b.dataset.id), 1)));
        listEl.querySelectorAll('.btn-edit').forEach(b=>b.addEventListener('click', ()=>openAfterFxParams(looper, parseInt(b.dataset.id))));
        listEl.querySelectorAll('.btn-bypass').forEach(b=>b.addEventListener('click', ()=>toggleAfterFxBypass(looper, parseInt(b.dataset.id))));
        listEl.querySelectorAll('.btn-remove').forEach(b=>b.addEventListener('click', ()=>removeAfterFx(looper, parseInt(b.dataset.id))));
    }

    function openTrackFxMenu(index) {
        const looper = engine.loopers[index];
        if (!looper) return;
        fxMenuPopup.classList.remove('hidden');
        fxMenuPopup.innerHTML = `<div class="fx-popup-inner">
            <h3>Track ${index} FX Chain</h3>
            <ul id="afterFxList" class="fx-list"></ul>
            <label>Add Effect: <select id="addFxSelect"><option value="">--Select--</option>${AFTER_FX_CATALOG.map(fx=>`<option value="${fx.type}">${fx.name}</option>`).join('')}</select></label>
            <button id="addFxBtn">Add</button> <button id="closeFxMenu">Close</button>
        </div>`;
        renderAfterFxList(looper);
        $('#addFxBtn').addEventListener('click', ()=>{ const v=$('#addFxSelect').value; if(v) addAfterFx(looper,v); });
        $('#closeFxMenu').addEventListener('click',()=>fxMenuPopup.classList.add('hidden'));
    }
    
    function openAfterFxParams(looper, fxId){
        const fx = looper.fx.chain.find(e=>e.id===fxId);
        if (!fx) return;
        fxParamsPopup.classList.remove('hidden');
        fxParamsPopup.innerHTML = `<div class="fx-popup-inner">
            <h3>Edit: ${fx.name}</h3>
            <div id="afterFxParamsBody">${renderAfterFxParams(looper, fx)}</div>
            <button id="closeFxParams">Close</button>
        </div>`;
        $('#closeFxParams').addEventListener('click', ()=>fxParamsPopup.classList.add('hidden'));
        wireAfterFxParams(looper, fx);
    }
    
    function renderAfterFxParams(looper, fx){
        const paramToHtml = (param, name, min, max, step, displayFn = v => v.toFixed(param.match(/q|pan|depth|duration|feedback/) ? 2 : 0)) => {
            const val = fx.params[param];
            const linkButtonHtml = `<button class="btn-link-fx" data-looper-index="${looper.index}" data-fx-id="${fx.id}" data-param="${param}">üîó</button>`;
            return `<label><span>${name} <span id="${param}Val">${displayFn(val)}</span></span> <div><input id="${param}" type="range" min="${min}" max="${max}" step="${step}" value="${val}">${linkButtonHtml}</div></label>`;
        };
        const selectToHtml = (param, name, options) => {
            const val = fx.params[param];
            const linkButtonHtml = `<button class="btn-link-fx" data-looper-index="${looper.index}" data-fx-id="${fx.id}" data-param="${param}" style="visibility:hidden;">üîó</button>`;
            const optionsHtml = options.map(o => `<option value="${o}" ${o === val ? 'selected' : ''}>${o}</option>`).join('');
            return `<label><span>${name}</span> <div><select id="${param}">${optionsHtml}</select>${linkButtonHtml}</div></label>`;
        };
        
        let html = '';
        if (fx.type === 'Pitch') html += paramToHtml('semitones', 'Semitones', -12, 12, 1, v => v.toFixed(0));
        if (fx.type === 'LowPass' || fx.type === 'HighPass' || fx.type === 'BandPass') {
            html += paramToHtml('cutoff', 'Cutoff', 50, 15000, 10);
            html += paramToHtml('q', 'Q', 0.1, 10, 0.1);
        }
        if (fx.type === 'Pan') html += paramToHtml('pan', 'Pan', -1, 1, 0.05);
        if (fx.type === 'Compressor') {
            html += paramToHtml('threshold', 'Threshold', -100, 0, 1, v => `${v.toFixed(0)} dB`);
            html += paramToHtml('ratio', 'Ratio', 1, 20, 1, v => `${v.toFixed(0)}:1`);
            html += paramToHtml('knee', 'Knee', 0, 40, 1, v => v.toFixed(0));
            html += paramToHtml('attack', 'Attack', 0, 1, 0.001, v => `${(v * 1000).toFixed(1)} ms`);
            html += paramToHtml('release', 'Release', 0, 1, 0.01, v => `${(v * 1000).toFixed(0)} ms`);
        }
        if (fx.type === 'Delay') {
            html += paramToHtml('mix', 'Mix', 0, 1, 0.01, v => `${(v*100).toFixed(0)}%`);
            html += paramToHtml('feedback', 'Feedback', 0, 0.95, 0.01, v => `${(v*100).toFixed(0)}%`);
            html += selectToHtml('division', 'Division', ['1/1','1/2','1/4','1/8','1/16','1/32']);
            html += selectToHtml('variant', 'Variant', ['straight', 'dotted', 'triplet']);
        }
        if (fx.type === 'Tremolo' || fx.type === 'Slicer') {
             html += paramToHtml('rate', 'Rate', 0.1, 20, 0.1, v => `${v.toFixed(1)} Hz`);
             html += paramToHtml('depth', 'Depth', 0.0, 1.0, 0.01, v => `${(v*100).toFixed(0)}%`);
        }
        if (fx.type === 'BeatRepeat') {
            html += paramToHtml('mix', 'Mix', 0, 1, 0.01, v => `${(v*100).toFixed(0)}%`);
            html += paramToHtml('repeats', 'Repeats', 1, 16, 1, v => v.toFixed(0));
            html += selectToHtml('division', 'Division', ['1/4','1/8','1/16','1/32']);
            html += `<div style="display:flex; gap:10px;"><button class="btn-trigger" id="triggerBeatRepeat">Trigger Repeat</button><button class="btn-link-fx" onclick="assignToActiveTrigger(${looper.index}, ${fx.id}, 'beatRepeat')" style="padding:4px 8px; font-size:0.8em;">Link to T?</button></div>`;
        }
        if (fx.type === 'VinylFlick') {
            html += paramToHtml('duration', 'Duration', 0.1, 1.0, 0.01);
            html += `<div style="display:flex; gap:10px;"><button class="btn-trigger" id="triggerVinylFlick">Trigger Flick</button><button class="btn-link-fx" onclick="assignToActiveTrigger(${looper.index}, ${fx.id}, 'vinylFlick')" style="padding:4px 8px; font-size:0.8em;">Link to T?</button></div>`;
        }
        return html || 'No parameters for this effect.';
    }
    
    function wireAfterFxParams(looper, fx){
        const setupSlider = (param, updateFn, valueFormatFn = v => v.toFixed(param.match(/q|pan|depth|duration|feedback/) ? 2 : 0)) => {
            const slider = $(`#${param}`);
            const valueLabel = $(`#${param}Val`);
            if (!slider || !valueLabel) return;
            slider.addEventListener('input', e => {
                const newValue = parseFloat(e.target.value);
                fx.params[param] = newValue;
                valueLabel.textContent = valueFormatFn(newValue);
                updateFn(newValue);

                const assignmentIdx = fxAssignments.findIndex(a => a && a.fxId === fx.id && a.param === param);
                if (assignmentIdx > -1) {
                    const assignment = fxAssignments[assignmentIdx];
                    const controlSlider = $(`#combinedFxControlSlider${assignmentIdx}`);
                    if (!assignment.isAutomationActive) {
                        controlSlider.value = newValue;
                        $(`#combinedFxControlValue${assignmentIdx}`).textContent = valueFormatFn(param, newValue);
                    } else {
                        // In automation mode, manual override sets the automation start/end points flat
                        assignment.points = [{t: 0, v: newValue}, {t: 1, v: newValue}];
                    }
                }
            });
        };
        const setupSelector = (param, updateFn) => {
            const selector = $(`#${param}`);
            if (!selector) return;
            selector.addEventListener('change', e => {
                fx.params[param] = e.target.value;
                updateFn(e.target.value);
            });
        };

        if (fx.type === 'Pitch') setupSlider('semitones', v => updateAudioNodeParam(looper, fx, 'semitones', v), v => v.toFixed(0));
        if (fx.type === 'LowPass' || fx.type === 'HighPass' || fx.type === 'BandPass') {
            setupSlider('cutoff', v => updateAudioNodeParam(looper, fx, 'cutoff', v));
            setupSlider('q', v => updateAudioNodeParam(looper, fx, 'q', v));
        }
        if (fx.type === 'Pan') setupSlider('pan', v => updateAudioNodeParam(looper, fx, 'pan', v));
        if (fx.type === 'Compressor') {
            setupSlider('threshold', v => updateAudioNodeParam(looper, fx, 'threshold', v), v => `${v.toFixed(0)} dB`);
            setupSlider('ratio', v => updateAudioNodeParam(looper, fx, 'ratio', v), v => `${v.toFixed(0)}:1`);
            setupSlider('knee', v => updateAudioNodeParam(looper, fx, 'knee', v), v => v.toFixed(0));
            setupSlider('attack', v => updateAudioNodeParam(looper, fx, 'attack', v), v => `${(v * 1000).toFixed(1)} ms`);
            setupSlider('release', v => updateAudioNodeParam(looper, fx, 'release', v), v => `${(v * 1000).toFixed(0)} ms`);
        }
        if (fx.type === 'Delay') {
            setupSlider('mix', v => updateAudioNodeParam(looper, fx, 'mix', v), v => `${(v*100).toFixed(0)}%`);
            setupSlider('feedback', v => updateAudioNodeParam(looper, fx, 'feedback', v), v => `${(v*100).toFixed(0)}%`);
            setupSelector('division', v => updateAudioNodeParam(looper, fx, 'division', v));
            setupSelector('variant', v => updateAudioNodeParam(looper, fx, 'variant', v));
        }
        if (fx.type === 'Tremolo' || fx.type === 'Slicer') {
             setupSlider('rate', v => updateAudioNodeParam(looper, fx, 'rate', v), v => `${v.toFixed(1)} Hz`);
             setupSlider('depth', v => updateAudioNodeParam(looper, fx, 'depth', v), v => `${(v*100).toFixed(0)}%`);
        }
        if (fx.type === 'BeatRepeat') {
            setupSlider('mix', v => fx.params.mix = v, v => `${(v*100).toFixed(0)}%`);
            setupSlider('repeats', v => fx.params.repeats = v, v => v.toFixed(0));
            setupSelector('division', v => fx.params.division = v);
            $('#triggerBeatRepeat')?.addEventListener('click', () => triggerBeatRepeat(looper, fx));
        }
        if (fx.type === 'VinylFlick') {
            setupSlider('duration', v => fx.params.duration = v);
            $('#triggerVinylFlick')?.addEventListener('click', () => triggerVinylFlick(looper, fx));
        }
        
        document.querySelectorAll('.btn-link-fx').forEach(linkBtn => {
             linkBtn.addEventListener('click', () => toggleLinkMode(linkBtn));
        });

        updateAllLinkButtonsUI();
    }
    
    // --- Utility Functions (GLOBALIZED) ---
    function triggerVinylFlick(looper, fx) {
        if (!looper.sourceNode) return;
        const currentPlaybackRate = looper.sourceNode.playbackRate.value;
        const param = looper.sourceNode.playbackRate;
        const now = audioCtx.currentTime;
        param.cancelScheduledValues(now);
        param.setTargetAtTime(0.01, now, fx.params.duration / 4);
        param.setTargetAtTime(currentPlaybackRate, now + fx.params.duration, 0.1);
    }

    function triggerBeatRepeat(looper, fx) {
        if (!fx.nodes) return;
        const { delay, feedback, wet, dry } = fx.nodes;
        const now = audioCtx.currentTime;
        
        const q = quarterSecForBPM(engine.masterBPM || 120);
        const repeatLen = q * (NOTE_MULT[fx.params.division] || 0.5);
        const totalDuration = repeatLen * fx.params.repeats;
        
        delay.delayTime.setValueAtTime(repeatLen, now);

        dry.gain.cancelScheduledValues(now);
        wet.gain.cancelScheduledValues(now);
        feedback.gain.cancelScheduledValues(now);

        dry.gain.linearRampToValueAtTime(0.0, now + 0.01);
        wet.gain.linearRampToValueAtTime(1.0, now + 0.01);
        feedback.gain.setValueAtTime(0.85, now);
        
        const endTime = now + totalDuration;
        feedback.gain.setValueAtTime(0.0, endTime);
        wet.gain.linearRampToValueAtTime(0.0, endTime + 0.05);
        dry.gain.linearRampToValueAtTime(1.0, endTime + 0.05);
    }
    
    // --- Looper Class and its immediate methods follow ---

    class Looper {
        constructor(index, engineRef){
            this.engine = engineRef;
            this.index = index;
            this.mainBtn = $(`#mainLooperBtn${index}`);
            this.stopBtn = $(`#stopBtn${index}`);
            this.looperIcon = $(`#looperIcon${index}`);
            this.ledRing = $(`#progressBar${index}`);
            this.stateDisplay = $(`#stateDisplay${index}`);
            this.deleteBtn = $(`#looper${index} .delete-track-btn`);
            this.state = 'ready';
            this.loopBuffer = null; this.sourceNode = null;
            this.loopStartTime = 0; this.loopDuration = 0;
            this.animationFrameId = null;
            this.divider = 1; this.uiDisabled = false;
            this.manualNudgeMs = -20;
            this.overdubGain = 1.0;
            this.overdubStartAudioTime = null;
            this.gainNode = this.engine.audioCtx.createGain();
            this.fx = { chain: [], nextId: 1 };

            const volSlider = $(`#volSlider${index}`);
            const volValue = $(`#volValue${index}`);
            this.gainNode.gain.value = 0.9;
            if (volSlider && volValue){
                volSlider.addEventListener('input', () => {
                    const v = parseInt(volSlider.value, 10);
                    this.gainNode.gain.value = v / 100;
                    volValue.textContent = v + '%';
                    
                    // NEW: Clear any active curve on manual override
                    delete activePresetTimeChain[this.index];

                });
            }

            if (index >= 2) {
                const dividerEl = $(`#divider${index}`);
                if (dividerEl) {
                    this.divider = parseFloat(dividerEl.value);
                    dividerEl.addEventListener('change', e => { this.divider = parseFloat(e.target.value); });
                }
                this.disable(true);
            }

            this.addEventListeners();
            this.updateUI();
            this.setRing(0);
        }

        addEventListeners() {
            addHold(this.stopBtn, () => this.clearLoop(), () => {
                // MODIFIED LOGIC: If recording, quick tap stops recording and processes data.
                if (this.state === 'recording') this.engine.stopRecording(this);
                else if (['playing', 'overdub', 'prerecord'].includes(this.state)) this.stopPlayback();
                else if (this.state === 'stopped') this.resumePlayback();
                else if (this.state === 'ready') this.clearLoop();
                else if (this.state === 'waiting') this.engine.abortRecording(this);
            });
            addTap(this.mainBtn, async () => { await this.engine.ensureMic(); await this.handleMainBtn(); });
            const fxBtn = $(`#fxMenuBtn${this.index}`);
            if (fxBtn) fxBtn.addEventListener('click', () => openTrackFxMenu(this.index));
            
            if (this.deleteBtn) {
                 this.deleteBtn.addEventListener('click', () => deleteLooperTrack(this.index));
            }
        }

        setRing(r) {
            if (!this.ledRing) return;
            const R = 46, C = 2 * Math.PI * R;
            this.ledRing.style.strokeDasharray = C;
            this.ledRing.style.strokeDashoffset = C * (1 - r);
        }

        updateUI(){
            const stateConfig = {
                ready:     { led: '#22c55e', icon: '‚ñ∂', text: 'Ready', btn: 'Record' },
                recording: { led: '#fde047', icon: '‚¶ø', text: 'Recording...', btn: 'Stop' },
                playing:   { led: '#22c55e', icon: '‚ñ∂', text: 'Playing', btn: 'Overdub' },
                prerecord: { led: '#3b82f6', icon: '‚¶ø', text: 'Preroll...', btn: 'Cancel OD' },
                overdub:   { led: '#f59e0b', icon: '‚¶ø', text: 'Overdubbing', btn: 'Stop OD' },
                stopped:   { led: '#6b7280', icon: '‚ñ†', text: 'Stopped', btn: 'Play' },
                waiting:   { led: '#6b7280', icon: '‚è≥', text: 'Waiting...', btn: '...' },
            };
            const config = stateConfig[this.state];
            if (!config) return;

            if (this.ledRing) {
                this.ledRing.style.stroke = config.led;
                this.ledRing.style.filter = (config.led==='#6b7280' ? 'none' : `drop-shadow(0 0 8px ${config.led}88)`);
            }
            if (this.looperIcon) this.looperIcon.textContent = config.icon;
            if (this.stateDisplay) this.stateDisplay.textContent = config.text;
            if (this.mainBtn) this.mainBtn.textContent = config.btn;

            if (this.state === 'stopped' || this.state === 'ready') this.setRing(0);

            const isDisabled = this.uiDisabled;
            if (this.mainBtn) { this.mainBtn.disabled = isDisabled; this.mainBtn.classList.toggle('disabled-btn', isDisabled); }
            if (this.stopBtn) { this.stopBtn.disabled = isDisabled; this.stopBtn.classList.toggle('disabled-btn', isDisabled); }
            if (isDisabled) this.stateDisplay.textContent = 'WAIT';
        }

        disable(v) { this.uiDisabled = v; this.updateUI(); }

        async handleMainBtn() {
            if (this.state === 'ready') this.phaseLockedRecord();
            else if (this.state === 'recording') this.engine.stopRecording(this);
            else if (this.state === 'playing') this.armOverdub();
            else if (['overdub', 'prerecord'].includes(this.state)) this.finishOverdub();
        }

        phaseLockedRecord() {
            if (this.index === 1 || !this.engine.masterIsSet) return this.engine.startRecording(this);
            this.state = 'waiting';
            this.updateUI();
            const master = this.engine.loopers[1];
            if (!master || !master.loopStartTime) {
                 this.engine.startRecording(this);
                 return;
            }
            const now = this.engine.audioCtx.currentTime;
            const elapsed = (now - master.loopStartTime) % master.loopDuration;
            const toNext = master.loopDuration - elapsed;
            setTimeout(() => this._startPhaseLockedRecording(master.loopDuration * this.divider), toNext * 1000);
        }

        _startPhaseLockedRecording(len) {
            this.engine.startRecording(this);
            setTimeout(() => {
                if (this.state === 'recording') this.engine.stopRecording(this);
            }, len * 1000);
        }

        _buildEffectNodes(effect){
            if (effect.nodes?.dispose){ try{ effect.nodes.dispose(); }catch{} }
            
            const common_dispose = (nodes) => {
                const allNodes = Object.values(nodes).filter(n => n instanceof AudioNode);
                allNodes.forEach(n => { try { n.disconnect() } catch {} });
            };
            const common_dispose_lfo = (nodes) => {
                if (nodes.lfo) { try { nodes.lfo.stop() } catch {} }
                common_dispose(nodes);
            };

            if (effect.type==='LowPass' || effect.type==='HighPass' || effect.type==='BandPass'){
                const input = audioCtx.createGain(), biq = audioCtx.createBiquadFilter(), output = audioCtx.createGain();
                biq.type = effect.type.toLowerCase(); 
                input.connect(biq); biq.connect(output);
                biq.frequency.value = effect.params.cutoff; biq.Q.value = effect.params.q;
                effect.nodes = { input, output, biq, dispose(){ common_dispose(this); } };
                return;
            }
            if (effect.type==='Pan'){
                const input = audioCtx.createGain(), output = audioCtx.createGain();
                const panner = (typeof audioCtx.createStereoPanner==='function') ? audioCtx.createStereoPanner() : null;
                if (panner){ input.connect(panner); panner.pan.value = effect.params.pan; }
                else { input.connect(output); }
                effect.nodes = { input, output, panner, dispose(){ common_dispose(this); } };
                return;
            }
            if (effect.type==='Pitch' || effect.type === 'VinylFlick'){
                const input = audioCtx.createGain(), output = audioCtx.createGain();
                input.connect(output);
                effect.nodes = { input, output, dispose(){} };
                return;
            }
            if (effect.type === 'Delay') {
                const input = audioCtx.createGain(), output = audioCtx.createGain();
                const delay = audioCtx.createDelay(2.0), feedback = audioCtx.createGain();
                const wet = audioCtx.createGain(), dry = audioCtx.createGain();
                input.connect(dry); dry.connect(output);
                input.connect(delay); delay.connect(feedback); feedback.connect(delay);
                delay.connect(wet); wet.connect(output);
                feedback.gain.value = effect.params.feedback;
                wet.gain.value = effect.params.mix; dry.gain.value = 1.0 - effect.params.mix;
                const updateDelayTimeFx = () => {
                    const q = quarterSecForBPM(engine.masterBPM || 120);
                    const mult = applyVariant(NOTE_MULT[effect.params.division] || 1, effect.params.variant);
                    delay.delayTime.value = engine.clamp(q * mult, 0.001, 2.0);
                };
                updateDelayTimeFx();
                effect.nodes = { input, output, delay, feedback, wet, dry, updateDelayTimeFx, dispose(){ common_dispose(this); } };
                return;
            }
             if (effect.type === 'Compressor') {
                const input = audioCtx.createGain(), output = audioCtx.createGain();
                const compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = effect.params.threshold; compressor.knee.value = effect.params.knee;
                compressor.ratio.value = effect.params.ratio; compressor.attack.value = effect.params.attack; compressor.release.value = effect.params.release;
                input.connect(compressor); compressor.connect(output);
                effect.nodes = { input, output, compressor, dispose(){ common_dispose(this); } };
                return;
            }
            if (effect.type === 'Tremolo' || effect.type === 'Slicer') {
                const input = audioCtx.createGain(), output = audioCtx.createGain(), tremoloGain = audioCtx.createGain();
                const lfo = audioCtx.createOscillator(), lfoDepth = audioCtx.createGain();
                lfo.type = (effect.type === 'Slicer') ? 'square' : 'sine';
                lfo.frequency.value = effect.params.rate;
                lfo.connect(lfoDepth); lfoDepth.connect(tremoloGain.gain);
                input.connect(tremoloGain); tremoloGain.connect(output);
                const depth = effect.params.depth; tremoloGain.gain.value = 1.0 - depth; lfoDepth.gain.value = depth;
                lfo.start();
                effect.nodes = { input, output, lfo, lfoDepth, tremoloGain, dispose(){ common_dispose_lfo(this); } };
                return;
            }
            if (effect.type === 'BeatRepeat') {
                const input = audioCtx.createGain(), output = audioCtx.createGain();
                const delay = audioCtx.createDelay(2.0), feedback = audioCtx.createGain();
                const wet = audioCtx.createGain(), dry = audioCtx.createGain();
                input.connect(dry); dry.connect(output);
                input.connect(delay); delay.connect(feedback); feedback.connect(delay);
                delay.connect(wet); wet.connect(output);
                dry.gain.value = 1.0; wet.gain.value = 0.0; feedback.gain.value = 0.0;
                effect.nodes = { input, output, delay, feedback, wet, dry, dispose(){ common_dispose(this); } };
                return;
            }
        }

        _rebuildChainWiring(){
            if (!this.sourceNode) return;
            try{ this.sourceNode.disconnect(); }catch{}
            
            const pitchFx = this.fx.chain.find(e=>e.type==='Pitch' && !e.bypass);
            this.sourceNode.playbackRate.value = Math.pow(2, (pitchFx?.params.semitones || 0)/12);
            
            let head = this.sourceNode;
            for (const fx of this.fx.chain){
                if (fx.bypass) continue;
                this._buildEffectNodes(fx);
                if (!fx.nodes || !fx.nodes.input || !fx.nodes.output) continue;
                try{ head.connect(fx.nodes.input); head = fx.nodes.output; }catch(e){console.warn('fx connect err',e)}
            }
            try{ head.connect(this.gainNode); }catch{}
            this.gainNode.connect(this.engine.audioCtx.destination);
        }

        startPlayback() {
            if (!this.loopBuffer) return;
            if (this.sourceNode) { try { this.sourceNode.stop(); this.sourceNode.disconnect(); } catch {} }
            this.sourceNode = this.engine.audioCtx.createBufferSource();
            this.sourceNode.buffer = this.loopBuffer;
            this.sourceNode.loop = true;

            let offset = 0;
            if (this.index !== 1 && this.engine.masterIsSet && this.engine.loopers[1] && this.engine.loopers[1].loopStartTime > 0 && this.engine.masterLoopDuration > 0) {
                 const master = this.engine.loopers[1];
                 const now = this.engine.audioCtx.currentTime - master.loopStartTime;
                 offset = now % master.loopDuration;
                 if (isNaN(offset) || offset < 0 || offset > this.loopBuffer.duration) offset = 0;
            }
            this.loopStartTime = this.engine.audioCtx.currentTime - offset;

            this._rebuildChainWiring();

            try{ this.sourceNode.start(0, offset); }catch{ try{ this.sourceNode.start(0,0); }catch{} }

            this.state = 'playing';
            this.updateUI();
            renderTrackFxSummary(this.index);
        }

        stopPlayback() {
            if (this.sourceNode) { try { this.sourceNode.stop(); } catch {} }
            this.state = 'stopped';
            this.updateUI();
        }

        resumePlayback() {
             if (this.index === 1) {
                this.startPlayback();
                for (let k = 2; k <= this.engine.looperCount; k++) {
                    const looper = this.engine.loopers[k];
                    if (looper && looper.state === 'stopped' && looper.loopBuffer) {
                        looper.startPlayback();
                    }
                }
            } else { this.startPlayback(); }
        }

        armOverdub() {
            if (this.state !== 'playing') return;
            this.state = 'prerecord';
            this.updateUI();
            if (this.engine.recorder) this.engine.recorder.start();

            const now = this.engine.audioCtx.currentTime;
            const elapsed = (now - this.loopStartTime) % this.loopDuration;
            const outputLatency = (typeof this.engine.audioCtx.outputLatency === 'number') ? this.engine.audioCtx.outputLatency : (this.engine.audioCtx.baseLatency || 0.040);
            let timeToNextLoop = (this.loopDuration - elapsed) - outputLatency;
            if (timeToNextLoop < 0) timeToNextLoop += this.loopDuration;

            setTimeout(() => this.startOverdubRecording(), timeToNextLoop * 1000);
        }

        startOverdubRecording() {
            if (this.state !== 'prerecord') return;
            this.state = 'overdub';
            this.updateUI();
            this.overdubStartAudioTime = this.engine.audioCtx.currentTime;
            if (this.engine.recorder) this.engine.recorder.markStart();
            setTimeout(() => { if (this.state === 'overdub') this.finishOverdub(); }, this.loopDuration * 1000);
        }

        finishOverdub() {
            if (!['overdub', 'prerecord'].includes(this.state)) return;
            if (this.state === 'overdub' && this.engine.recorder) {
                 this.engine.recorder.stop();
            } else {
                 if (this.engine.recorder) this.engine.recorder.stop();
                 this.state = 'playing';
                 this.updateUI();
            }
        }

        clearLoop() {
            this.stopPlayback();
            this.loopBuffer = null; this.loopDuration = 0;
            this.state = 'ready'; this.updateUI();
            if (this.index === 1) {
                engine.masterLoopDuration = null;
                engine.masterBPM = null;
                engine.masterIsSet = false;
                bpmLabel.textContent = 'BPM: --';
                updateDelayTime(preFxNodes.delay.params);
                for (let k = 1; k <= engine.looperCount; k++) {
                    const looper = engine.loopers[k];
                    if (looper) {
                        if (k > 1) {
                            looper.disable(true);
                            looper.clearLoop();
                        }
                        looper.setRing(0);
                     }
                }
            }
        }

        animateMasterInitialRecording(durationMs) {
            const startTime = Date.now();
            const loop = () => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / durationMs, 1);
                this.setRing(progress);
                if (progress < 1) {
                    this.animationFrameId = requestAnimationFrame(loop);
                }
            };
            this.animationFrameId = requestAnimationFrame(loop);
        }
    }
    
    function deleteLooperTrack(index) {
        if (index === 1) {
            engine.showMsg("Cannot delete the Master Looper Track.", "#f43f5e");
            return;
        }
        if (index > engine.looperCount) return;

        // 1. Remove the looper instance and clear its effects
        const looperToDelete = engine.loopers[index];
        if (looperToDelete) {
             looperToDelete.clearLoop();
             looperToDelete.gainNode.disconnect();
             engine.loopers[index] = null;
        }

        // 2. Remove from DOM
        const pedalElement = $(`#looper${index}`);
        if (pedalElement) {
            pedalElement.remove();
        }

        // 3. Update Looper Count and re-index the loopers array and UI
        for (let i = index + 1; i <= engine.looperCount; i++) {
            const currentLooper = engine.loopers[i];
            if (currentLooper) {
                // Shift the object reference
                engine.loopers[i - 1] = currentLooper;
                currentLooper.index = i - 1;

                // Update DOM IDs and text
                const oldPedal = $(`#looper${i}`);
                if (oldPedal) {
                    oldPedal.id = `looper${i - 1}`;
                    oldPedal.querySelector('.track-label').textContent = `TRACK ${i - 1}`;
                    const deleteBtn = oldPedal.querySelector('.delete-track-btn');
                    if(deleteBtn) deleteBtn.dataset.trackId = i - 1;
                    $(`#progressBar${i}`).id = `progressBar${i - 1}`;
                    $(`#looperIcon${i}`).id = `looperIcon${i - 1}`;
                    $(`#stateDisplay${i}`).id = `stateDisplay${i - 1}`;
                    $(`#volSlider${i}`).id = `volSlider${i - 1}`;
                    $(`#volValue${i}`).id = `volValue${i - 1}`;
                    $(`#trackFxLabels${i}`).id = `trackFxLabels${i - 1}`;
                    $(`#divider${i}`).id = `divider${i - 1}`;
                    $(`#mainLooperBtn${i}`).id = `mainLooperBtn${i - 1}`;
                    $(`#stopBtn${i}`).id = `stopBtn${i - 1}`;
                    $(`#fxMenuBtn${i}`).id = `fxMenuBtn${i - 1}`;
                    
                    // Re-bind events (simpler than updating all listeners)
                    currentLooper.addEventListeners();
                    currentLooper.updateUI();
                }
            }
            engine.loopers[i] = null; // Clear the old index slot
        }

        // 4. Update looper count
        engine.looperCount--;
        
        // 5. Restore Add Looper button if needed
        $('#addLooperBtn').classList.remove('hidden');
        
        // 6. Update Performance Assignments
        for (let i = 0; i < triggerAssignments.length; i++) {
            if (triggerAssignments[i] && triggerAssignments[i].looperIndex > index) {
                triggerAssignments[i].looperIndex -= 1;
            }
            // Update trigger glow status
            updateTriggerPadGlow(i); 
        }
        for (let i = 0; i < macroAssignments.length; i++) {
            macroAssignments[i] = macroAssignments[i].filter(a => a.type === 'control' || a.looperIndex !== index).map(a => {
                 // Update Looper FX assignments
                if (a.type === 'fx' && a.looperIndex > index) a.looperIndex -= 1;
                
                // If the assignment was to a Combined FX slot, check if that slot still points to a valid FX/Looper
                if (a.type === 'control') {
                    const control = fxAssignments[a.controlIndex];
                    if (control && control.looperIndex === index) {
                         // The associated FX control must be unassigned/re-evaluated
                         // For now, we rely on unassignFxControl handling removal and keep the macro link simple
                         // It's cleaner to remove the macro link if the underlying FX is gone.
                         return null; // Flag for removal below
                    } else if (control && control.looperIndex > index) {
                         // If the control slot is still assigned but the looper index shifted
                         control.looperIndex -= 1; 
                    }
                }
                return a;
            }).filter(a => a !== null);
             updateMacroBtnGlow(i); // Update macro glow status
        }
        for (let i = 0; i < fxAssignments.length; i++) {
            if (fxAssignments[i] && fxAssignments[i].looperIndex > index) {
                fxAssignments[i].looperIndex -= 1;
            } else if (fxAssignments[i] && fxAssignments[i].looperIndex === index) {
                unassignFxControl(i); // Unassign if the linked track is deleted
            }
        }


        engine.showMsg(`Track ${index} deleted. Tracks re-indexed.`, '#fde047');
    }
    
    


    function masterAnimationLoop() {
        engine.globalAnimationId = requestAnimationFrame(masterAnimationLoop);
        const master = engine.loopers[1];
        if (!master || !master.loopBuffer || master.state === 'stopped' || master.state === 'ready' || !engine.masterIsSet) {
             engine.loopers.forEach(lp => { if(lp && lp.state !== 'recording') lp.setRing(0); });
             return;
        }
        
        // --- Calculate Master Loop Progress (0.0 to 1.0) ---
        const masterLoopProgress = ((engine.audioCtx.currentTime - master.loopStartTime) % master.loopDuration) / master.loopDuration;

        engine.loopers.forEach(lp => {
            if (!lp) return;
            const activeStates = ['playing', 'overdub', 'prerecord', 'waiting'];
            if (activeStates.includes(lp.state) || (lp.state === 'recording' && lp.index > 1)) {
                lp.setRing(masterLoopProgress);
            }
            
            // --- NEW: Apply Volume Curve if active ---
            const timeChain = activePresetTimeChain[lp.index];
            if (timeChain) {
                const currentTime = engine.audioCtx.currentTime;
                
                // Calculate how far along the curve we are (0.0 to 1.0)
                let curveProgress = engine.clamp((currentTime - timeChain.startTime) / timeChain.duration, 0.0, 1.0);
                
                const volumeValue = getInterpolatedValue(timeChain.points, curveProgress) / 100.0;
                
                // Smoothly set gain value
                lp.gainNode.gain.value = engine.clamp(volumeValue, 0, 1.2);

                // Update UI slider to follow the curve
                const volSlider = $(`#volSlider${lp.index}`);
                const volValue = $(`#volValue${lp.index}`);
                if (volSlider) volSlider.value = volumeValue * 100;
                if (volValue) volValue.textContent = `${(volumeValue * 100).toFixed(0)}%`;

                // Stop curve processing once finished
                if (curveProgress >= 1.0) {
                     delete activePresetTimeChain[lp.index];
                     // Ensure final value sticks if the curve ended
                     lp.gainNode.gain.value = timeChain.points[timeChain.points.length - 1].v / 100.0;
                }
            }

        });

        fxAssignments.forEach((assignment, index) => {
            if (!assignment || !assignment.isAutomationActive) return;
            
            const slider = $(`#combinedFxControlSlider${index}`);
            
            // Note: FX Automation uses masterLoopProgress (0.0 to 1.0)
            const currentValue = getInterpolatedValue(assignment.points, masterLoopProgress); 
            
            slider.value = currentValue;
            const valueFormatFn = (p, v) => v.toFixed(p.match(/q|pan|depth|duration|feedback/) ? 2 : 0);
            $(`#combinedFxControlValue${index}`).textContent = valueFormatFn(assignment.param, currentValue);
            
            const { looperIndex, fxId, param } = assignment;
            const looper = engine.loopers[looperIndex];
            const fx = looper ? looper.fx.chain.find(f => f.id === fxId) : null;
            
            if (looper && fx) {
                fx.params[param] = currentValue;
                updateAudioNodeParam(looper, fx, param, currentValue);
            }
        });
    }

  // ===== PERFORMANCE PEDAL LOGIC (Cleaned up reference issue in deleteLooperTrack) =====
  function initPerformanceControls() {
      // Corrected the index of buttons for clarity (0-based)
      [0, 1].forEach(i => {
          document.getElementById(`assignTrigger${i}`).addEventListener('click', () => toggleLearningMode('trigger', i));
          const pad = document.getElementById(`triggerPad${i+1}`);
          pad.addEventListener('mousedown', () => fireTrigger(i));
          pad.addEventListener('touchstart', (e) => { e.preventDefault(); fireTrigger(i); });
          updateTriggerPadGlow(i); // Initial glow status
      });
      [0, 1, 2, 3].forEach(i => {
          document.getElementById(`assignMacro${i}`).addEventListener('click', () => toggleLearningMode('macro', i));
          document.getElementById(`macroBtn${i}`).addEventListener('click', () => fireMacro(i));
          document.querySelector(`.perf-switch-settings[data-macro-index="${i}"]`).addEventListener('click', () => openMacroManagementPopup(i)); // NEW
          updateMacroBtnGlow(i); // Initial glow status
      });
  }
  
  // NEW: Function to toggle T1/T2 glow
  function updateTriggerPadGlow(index) {
      const pad = document.getElementById(`triggerPad${index + 1}`);
      if (!pad) return;
      const isAssigned = triggerAssignments[index] !== null;
      pad.classList.toggle('linked', isAssigned);
  }
  
  // NEW: Function to toggle Macro settings glow
  function updateMacroBtnGlow(index) {
      const macroBtn = document.getElementById(`macroBtn${index}`);
      if (!macroBtn) return;
      const isAssigned = macroAssignments[index].length > 0;
      macroBtn.classList.toggle('linked', isAssigned); // Use the same CSS class for visual link feedback
  }

  function toggleLearningMode(type, index) {
      if (learningState.type === type && learningState.index === index) {
          learningState = { type: null, index: null };
      } else {
          learningState = { type, index };
      }
      document.querySelectorAll('.btn-assign-small').forEach(b => b.classList.remove('learning'));
      if (learningState.type) {
          const id = learningState.type === 'trigger' ? `assignTrigger${learningState.index}` : `assignMacro${learningState.index}`;
          document.getElementById(id).classList.add('learning');
      }
  }

  function fireTrigger(index) {
      const assign = triggerAssignments[index];
      if (!assign) return;
      const looper = engine.loopers[assign.looperIndex];
      const fx = looper?.fx.chain.find(f => f.id === assign.fxId);
      if (!looper || !fx) return;
      if (assign.action === 'vinylFlick') triggerVinylFlick(looper, fx);
      if (assign.action === 'beatRepeat') triggerBeatRepeat(looper, fx);
      const pad = document.getElementById(`triggerPad${index+1}`);
      pad.style.borderColor = 'white';
      setTimeout(() => pad.style.borderColor = '', 100);
  }

  function fireMacro(index) {
      const btn = document.getElementById(`macroBtn${index}`);
      const isActive = btn.classList.toggle('active');
      const assignments = macroAssignments[index];

      // 1. Toggle Looper FX Bypass State (type: 'fx')
      assignments.filter(a => a.type === 'fx').forEach(a => {
          const looper = engine.loopers[a.looperIndex];
          const fx = looper?.fx.chain.find(f => f.id === a.fxId);
          if (fx) {
              fx.bypass = !isActive;
              looper._rebuildChainWiring();
              renderAfterFxList(looper); // Ensure UI updates
          }
      });
      
      // 2. Map Macro to Combined FX Controls (type: 'control')
      assignments.filter(a => a.type === 'control').forEach(a => {
          const assignment = fxAssignments[a.controlIndex];
          if (!assignment) return; // Skip if the linked control slot is empty

          const ledBtn = $(`#combinedLedBtn${a.controlIndex}`);
          const editBtn = $(`#combinedEditBtn${a.controlIndex}`);
          const slider = $(`#combinedFxControlSlider${a.controlIndex}`);

          if (isActive) {
              // If macro ON, force automation ON for assigned FX
              assignment.isAutomationActive = true;
              ledBtn?.classList.add('active');
              editBtn.disabled = false;
              slider.disabled = true;
          } else {
              // If macro OFF, force automation OFF for assigned FX
              assignment.isAutomationActive = false;
              ledBtn?.classList.remove('active');
              editBtn.disabled = true;
              slider.disabled = false;
          }
      });
  }

  window.assignToActiveTrigger = (looperIndex, fxId, action) => {
      if (learningState.type !== 'trigger') {
          engine.showMsg("Enable 'Link' on T1 or T2 first.", "#fde047");
          return;
      }
      triggerAssignments[learningState.index] = { looperIndex, fxId, action };
      document.getElementById(`triggerPad${learningState.index + 1}`).textContent = action === 'vinylFlick' ? 'Flick' : 'Rpt';
      engine.showMsg(`Linked T${learningState.index + 1}`, "#21f7a8");
      updateTriggerPadGlow(learningState.index); // Update glow
      toggleLearningMode('trigger', learningState.index);
  };

  window.handleBypassClick = (looperIndex, fxId) => {
      const looper = engine.loopers[looperIndex];
      if (!looper) return;
      const fx = looper.fx.chain.find(e=>e.id===fxId);
      if (!fx) return;

      if (learningState.type === 'macro') {
          const macroIdx = learningState.index;
          const list = macroAssignments[macroIdx];
          
          // 1. Check if the FX is already in the list (type: 'fx')
          const existsFx = list.findIndex(a => a.type === 'fx' && a.looperIndex === looperIndex && a.fxId === fxId);
          
          if (existsFx > -1) {
              list.splice(existsFx, 1);
              engine.showMsg(`Removed ${fx.name} from M${macroIdx + 1}`);
          } else {
              list.push({ type: 'fx', looperIndex, fxId }); // Store as FX assignment
              engine.showMsg(`Added ${fx.name} to M${macroIdx + 1}`, "#21f7a8");
          }
          updateMacroBtnGlow(macroIdx);
          renderMacroAssignmentList(macroIdx); // Update macro popup list if open
      } else {
          toggleAfterFxBypass(looper, fxId);
      }
  };

  // NEW: Macro Management Popup Functions
  function openMacroManagementPopup(macroIndex) {
      macroManagementPopup.classList.remove('hidden');
      
      const fxControlAssignmentsHtml = fxAssignments.map((assignment, controlIndex) => {
          if (!assignment) return '';

          const isMacroLinked = macroAssignments[macroIndex].some(a => a.type === 'control' && a.controlIndex === controlIndex);
          const linkBtnText = isMacroLinked ? 'Unlink' : 'Link';
          const btnClass = isMacroLinked ? 'btn stop-btn' : 'btn main-looper-btn';
          
          return `
              <li style="display:flex; justify-content:space-between; align-items:center;">
                  <span class="fx-name">C${controlIndex + 1}: ${assignment.type} ${assignment.param} (T${assignment.looperIndex})</span>
                  <button class="${btnClass}" data-control-index="${controlIndex}" onclick="toggleMacroControlLink(${macroIndex}, ${controlIndex})">${linkBtnText}</button>
              </li>
          `;
      }).join('');
      
      macroManagementPopup.innerHTML = `
          <div class="fx-popup-inner" style="min-width: 400px; max-width: 500px;">
              <h3>Macro M${macroIndex + 1} Settings</h3>
              
              <div style="margin-bottom: 20px;">
                  <h4>FX Bypass/Unbypass Assignments</h4>
                  <p style="color: var(--accent-yellow); font-size: 0.9em; margin-bottom: 10px;">(Toggles ON/OFF status of linked FX.)</p>
                  <div id="macroFxAssignmentList"></div>
              </div>

              <div>
                  <h4>Automation Control Assignments</h4>
                  <p style="color: var(--accent-blue); font-size: 0.9em; margin-bottom: 10px;">(Toggles the green Automation LED (Manual/Curve) for linked control slots.)</p>
                  <ul class="fx-list">
                      ${fxControlAssignmentsHtml || '<p style="text-align:center; color:#94a3b8;">No combined control slots are currently active.</p>'}
                  </ul>
              </div>

              <button id="closeMacroPopupBtn" class="btn stop-btn" style="width:100%;">Close</button>
          </div>
      `;
      
      $('#closeMacroPopupBtn').addEventListener('click', () => macroManagementPopup.classList.add('hidden'));
      renderMacroAssignmentList(macroIndex); // Render the FX Bypass list inside the new structure
  }

  // NEW: Function to handle linking Combined FX Control to Macro
  window.toggleMacroControlLink = (macroIndex, controlIndex) => {
      const macro = macroAssignments[macroIndex];
      const indexToRemove = macro.findIndex(a => a.type === 'control' && a.controlIndex === controlIndex);
      
      const control = fxAssignments[controlIndex];
      const controlLabel = $(`#combinedFxControlLabel${controlIndex}`).textContent;

      if (indexToRemove > -1) {
          // Unlink
          macro.splice(indexToRemove, 1);
          engine.showMsg(`Unlinked C${controlIndex + 1} from M${macroIndex + 1}`, '#f43f5e');
      } else if (control) {
          // Link (if control is assigned)
          macro.push({ type: 'control', controlIndex });
          engine.showMsg(`Linked C${controlIndex + 1} to M${macroIndex + 1}`, "#21f7a8");
      } else {
          engine.showMsg(`C${controlIndex + 1} is unassigned. Link an FX first.`, '#fde047');
      }

      // Re-render the Macro Settings popup list and update glow
      openMacroManagementPopup(macroIndex);
      updateMacroBtnGlow(macroIndex);
  };


  function renderMacroAssignmentList(macroIndex) {
      const listEl = $('#macroFxAssignmentList');
      if (!listEl) return;
      
      const assignments = macroAssignments[macroIndex].filter(a => a.type === 'fx');
      if (assignments.length === 0) {
          listEl.innerHTML = '<p style="text-align:center; color:#94a3b8;">No FX Bypass assignments linked.</p>';
          return;
      }

      listEl.innerHTML = `
          <ul class="fx-list">
              ${assignments.map(a => {
                  const looper = engine.loopers[a.looperIndex];
                  const fx = looper?.fx.chain.find(f => f.id === a.fxId);
                  if (!looper || !fx) return '';
                  return `
                      <li>
                          <span class="fx-name">T${a.looperIndex}: ${fx.name} (Bypass)</span>
                          <span class="fx-controls">
                              <button class="btn-remove stop-btn" data-looper-index="${a.looperIndex}" data-fx-id="${a.fxId}">‚úï</button>
                          </span>
                      </li>
                  `;
              }).join('')}
          </ul>
      `;

      listEl.querySelectorAll('.btn-remove').forEach(btn => {
          btn.addEventListener('click', (e) => {
              const looperIndex = parseInt(e.target.dataset.looperIndex);
              const fxId = parseInt(e.target.dataset.fxId);
              
              // Remove the assignment from the list
              const list = macroAssignments[macroIndex];
              const indexToRemove = list.findIndex(a => a.type === 'fx' && a.looperIndex === looperIndex && a.fxId === fxId);
              if (indexToRemove > -1) {
                  list.splice(indexToRemove, 1);
              }
              
              // This is a bypass assignment, toggling active status on M button click is enough
              
              updateMacroBtnGlow(macroIndex);
              renderMacroAssignmentList(macroIndex); // Re-render the list
              engine.showMsg(`Removed T${looperIndex}: ${fx.name} from M${macroIndex + 1}`, '#f43f5e');
          });
      });
  }


    function updateAudioNodeParam(looper, fx, param, value) {
        if (!fx.nodes) looper._buildEffectNodes(fx);
        if (!fx.nodes) return;
        if (fx.type === 'Pitch' && param === 'semitones') { if (looper.sourceNode) looper.sourceNode.playbackRate.value = Math.pow(2, value / 12); }
        else if (param === 'cutoff') { if (fx.nodes.biq) fx.nodes.biq.frequency.value = value; }
        else if (param === 'q') { if (fx.nodes.biq) fx.nodes.biq.Q.value = value; }
        else if (param === 'Pan' && param === 'pan') { if (fx.nodes.panner) fx.nodes.panner.pan.value = value; }
        else if (fx.type === 'Compressor' && fx.nodes.compressor) { if (fx.nodes.compressor[param]) { fx.nodes.compressor[param].value = value; } }
        else if (fx.type === 'Delay') {
            if (param === 'mix' && fx.nodes.wet && fx.nodes.dry) { fx.nodes.wet.gain.value = value; fx.nodes.dry.gain.value = 1.0 - value; }
            if (param === 'feedback' && fx.nodes.feedback) { fx.nodes.feedback.gain.value = value; }
            if ((param === 'division' || param === 'variant') && fx.nodes.updateDelayTimeFx) { fx.nodes.updateDelayTimeFx(); }
        }
        else if (fx.type === 'Tremolo' || fx.type === 'Slicer') {
             if (param === 'rate' && fx.nodes.lfo) { fx.nodes.lfo.frequency.value = value; }
             if (param === 'depth' && fx.nodes.lfoDepth && fx.nodes.tremoloGain) { fx.nodes.tremoloGain.gain.value = 1.0 - value; fx.nodes.lfoDepth.gain.value = value; }
        }
    }

    // --- NEW: Combined FX Control Initialization ---
    function initCombinedFxControls() {
        const grid = document.querySelector('#combined-fx-control-grid');
        grid.innerHTML = '';
        for (let i = 0; i < 4; i++) {
            const wrapper = document.createElement('div');
            wrapper.className = 'combined-fx-slider-wrapper';
            wrapper.id = `combined-fx-control-wrapper-${i}`;
            wrapper.innerHTML = `
                <label class="combined-fx-slider-label" id="combinedFxControlLabel${i}">SLOT ${i + 1}: Unassigned</label>
                <div class="fx-slider-controls">
                    <button class="led-btn" id="combinedLedBtn${i}" title="Toggle Automation"></button>
                    <button class="btn edit-automation-btn" id="combinedEditBtn${i}" disabled>Graph</button>
                </div>
                <div class="fx-slider-input-area">
                    <input type="range" id="combinedFxControlSlider${i}" min="0" max="100" value="50" disabled>
                </div>
                <span class="fx-slider-value" id="combinedFxControlValue${i}">--</span>
            `;
            grid.appendChild(wrapper);

            // --- Event Listeners ---
            wrapper.addEventListener('click', () => { if (linkingState.active) assignFxControl(i); });
            
            // Green LED button logic (Toggle Automation/Manual Mode)
            $(`#combinedLedBtn${i}`).addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent the parent wrapper click handler (linking)
                const assignment = fxAssignments[i];
                if (!assignment) return;
                
                const isNowActive = !assignment.isAutomationActive;
                assignment.isAutomationActive = isNowActive;
                e.target.classList.toggle('active', isNowActive);
                
                const slider = $(`#combinedFxControlSlider${i}`);
                const editBtn = $(`#combinedEditBtn${i}`);
                
                slider.disabled = isNowActive; // Disable manual input in Automation mode
                editBtn.disabled = !isNowActive; // Enable graph button only in Automation mode
                
                if (isNowActive) {
                    engine.showMsg(`Slot ${i+1} activated: Automation Mode`, '#21f7a8');
                } else {
                    engine.showMsg(`Slot ${i+1} activated: Manual Mode`, '#38b6ff');
                    
                    // Immediately push the current slider value (which reflects the manual position) to the audio param
                    const valueFormatFn = (p, v) => v.toFixed(p.match(/q|pan|depth|duration|feedback/) ? 2 : 0);
                    const currentValue = parseFloat(slider.value);
                    assignment.points = [{t: 0, v: currentValue}, {t: 1, v: currentValue}]; // Reset curve to flat at manual value
                    
                    const looper = engine.loopers[assignment.looperIndex];
                    const fx = looper ? looper.fx.chain.find(f => f.id === assignment.fxId) : null;
                    if (looper && fx) {
                         fx.params[assignment.param] = currentValue;
                         updateAudioNodeParam(looper, fx, assignment.param, currentValue);
                         $(`#combinedFxControlValue${i}`).textContent = valueFormatFn(assignment.param, currentValue);
                    }
                }
            });
            
            // Graph Edit button logic
             $(`#combinedEditBtn${i}`).addEventListener('click', (e) => {
                e.stopPropagation();
                if (fxAssignments[i] && fxAssignments[i].isAutomationActive) openAutomationPopup(i);
            });
            
            // Manual Slider input logic (only active when not in automation mode)
            $(`#combinedFxControlSlider${i}`).addEventListener('input', (e) => {
                const assignment = fxAssignments[i];
                if (!assignment || assignment.isAutomationActive) return;

                const newValue = parseFloat(e.target.value);
                const { looperIndex, fxId, param, popupSliderId } = assignment;
                const looper = engine.loopers[looperIndex];
                if (!looper) return;
                const fx = looper.fx.chain.find(f => f.id === fxId);
                
                const valueFormatFn = (p, v) => v.toFixed(p.match(/q|pan|depth|duration|feedback/) ? 2 : 0);
                
                if (looper && fx) {
                    fx.params[param] = newValue;
                    updateAudioNodeParam(looper, fx, param, newValue);
                    $(`#combinedFxControlValue${i}`).textContent = valueFormatFn(param, newValue);
                    
                    // Update the corresponding popup slider and value
                    const popupSlider = document.getElementById(popupSliderId);
                    if (popupSlider && document.body.contains(popupSlider)) {
                        popupSlider.value = newValue;
                        const valueLabel = popupSlider.closest('label').querySelector('span span');
                        if (valueLabel) valueLabel.textContent = valueFormatFn(param, newValue);
                    }
                    
                    // Update the automation points to maintain "current value" even in manual mode
                    assignment.points = [{t: 0, v: newValue}, {t: 1, v: newValue}];
                }
            });
        }
    }


    function toggleLinkMode(button) {
        const { looperIndex, fxId, param } = button.dataset;
        const index = fxAssignments.findIndex(a => a && a.looperIndex == looperIndex && a.fxId == fxId && a.param == param);

        if (index > -1) {
            unassignFxControl(index);
        } else {
            startLinkingMode(button);
        }
    }

    function startLinkingMode(button) {
        endLinkingMode(false);
        const { looperIndex, fxId, param, popupSliderId } = button.dataset;
        const sourceSlider = document.getElementById(param);

        linkingState = {
            active: true,
            looperIndex: parseInt(looperIndex),
            fxId: parseInt(fxId),
            param: param,
            sourceElement: button,
            popupSliderId: sourceSlider ? sourceSlider.id : param // Fallback if ID is missing
        };
        engine.showMsg("Select an empty FX Control slot to link.");
        document.querySelectorAll('.combined-fx-slider-wrapper').forEach((el, i) => {
            if (fxAssignments[i] === null) el.classList.add('assignable');
        });
    }

    function endLinkingMode(showMsgSuccess = true) {
        if (!linkingState.active) return;
        if (showMsgSuccess) engine.showMsg("FX control linked!", "#21f7a8");
        linkingState.active = false;
        linkingState.sourceElement = null;
        document.querySelectorAll('.combined-fx-slider-wrapper.assignable').forEach(el => el.classList.remove('assignable'));
    }

    function assignFxControl(sliderIndex) {
        if (fxAssignments[sliderIndex] !== null) {
            engine.showMsg("This slot is already assigned. Unlink it first.", '#f43f5e'); return;
        }

        const { looperIndex, fxId, param, popupSliderId } = linkingState;
        const looper = engine.loopers[looperIndex];
        const fx = looper.fx.chain.find(f => f.id === fxId);
        const sourceSlider = document.getElementById(popupSliderId);
        
        if (!looper || !fx || !sourceSlider) {
             endLinkingMode(false);
             return;
        }

        const initialValue = parseFloat(sourceSlider.value);
        const valueFormatFn = (p, v) => v.toFixed(p.match(/q|pan|depth|duration|feedback/) ? 2 : 0);

        fxAssignments[sliderIndex] = {
            looperIndex, fxId, param, popupSliderId,
            isAutomationActive: false, // Default to Manual mode
            points: [ {t: 0, v: initialValue}, {t: 1, v: initialValue} ], // Flat curve at initial value
            min: parseFloat(sourceSlider.min),
            max: parseFloat(sourceSlider.max),
            type: fx.type
        };

        const controlSlider = $(`#combinedFxControlSlider${sliderIndex}`);
        controlSlider.min = sourceSlider.min;
        controlSlider.max = sourceSlider.max;
        controlSlider.step = sourceSlider.step;
        controlSlider.value = initialValue;
        controlSlider.disabled = false;
        
        $(`#combinedFxControlLabel${sliderIndex}`).textContent = `T${looperIndex}: ${fx.name} ${param}`;
        $(`#combinedFxControlValue${sliderIndex}`).textContent = valueFormatFn(param, initialValue);
        
        $(`#combinedLedBtn${sliderIndex}`).classList.remove('active');
        $(`#combinedEditBtn${sliderIndex}`).disabled = true;

        endLinkingMode();
        updateAllLinkButtonsUI();
    }

    function unassignFxControl(sliderIndex) {
        // Remove any macro links pointing to this control slot
        for (let i = 0; i < macroAssignments.length; i++) {
            macroAssignments[i] = macroAssignments[i].filter(a => !(a.type === 'control' && a.controlIndex === sliderIndex));
            updateMacroBtnGlow(i);
        }

        fxAssignments[sliderIndex] = null;
        
        const controlSlider = $(`#combinedFxControlSlider${sliderIndex}`);
        controlSlider.disabled = true;
        controlSlider.value = 50; controlSlider.min = 0; controlSlider.max = 100; // Reset visual range
        
        $(`#combinedFxControlLabel${sliderIndex}`).textContent = `SLOT ${sliderIndex + 1}: Unassigned`;
        $(`#combinedFxControlValue${sliderIndex}`).textContent = '--';
        
        $(`#combinedLedBtn${sliderIndex}`).classList.remove('active');
        $(`#combinedEditBtn${sliderIndex}`).disabled = true;

        engine.showMsg(`Slot ${sliderIndex + 1} unlinked.`, "#38b6ff");
        updateAllLinkButtonsUI();
    }

    function updateAllLinkButtonsUI() {
        document.querySelectorAll('.btn-link-fx').forEach(btn => {
            const { looperIndex, fxId, param } = btn.dataset;
            const index = fxAssignments.findIndex(a => a && a.looperIndex == looperIndex && a.fxId == fxId && a.param == param);

            if (index > -1) {
                btn.classList.add('linked');
                btn.textContent = `üîó C${index + 1}`; // C for Combined
            } else {
                btn.classList.remove('linked');
                btn.textContent = 'üîó';
            }
        });
    }

    function openAutomationPopup(index) {
        const assignment = fxAssignments[index];
        if (!assignment || !assignment.isAutomationActive) return;

        const popup = $('#automationPopup');
        popup.classList.remove('hidden');
        popup.innerHTML = `
            <div class="fx-popup-inner">
                <h3>Automation for Slot ${index + 1} (${assignment.type} ${assignment.param})</h3>
                <p style="font-size:0.9em; margin-top:-10px; color: var(--text-secondary);">X-Axis: Loop Position | Y-Axis: Parameter Value (${assignment.min.toFixed(0)} to ${assignment.max.toFixed(0)})</p>
                <canvas id="automationCanvas" width="400" height="200"></canvas>
                <div>
                  <button id="resetAutomationBtn" class="btn">Reset to Flat</button>
                  <button id="closeAutomationPopup" class="btn">Close</button>
                </div>
            </div>
        `;

        const canvas = $('#automationCanvas');
        const ctx = canvas.getContext('2d');
        let points = assignment.points;
        let draggingPoint = null;

        const width = canvas.width, height = canvas.height;
        const padding = 20;

        const valToY = v => padding + (1 - (engine.clamp(v, assignment.min, assignment.max) - assignment.min) / (assignment.max - assignment.min)) * (height - 2 * padding);
        const timeToX = t => padding + t * (width - 2 * padding);
        const xToTime = x => (x - padding) / (width - 2 * padding);
        const yToVal = y => assignment.min + (1 - (y - padding) / (height - 2 * padding)) * (assignment.max - assignment.min);

        const redraw = () => {
            ctx.clearRect(0, 0, width, height);
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
            for (let i = 1; i < 4; i++) {
                ctx.beginPath(); ctx.moveTo(padding + i*(width-2*padding)/4, padding); ctx.lineTo(padding + i*(width-2*padding)/4, height-padding); ctx.stroke();
                ctx.beginPath(); ctx.moveTo(padding, padding + i*(height-2*padding)/4); ctx.lineTo(width-padding, padding + i*(height-2*padding)/4); ctx.stroke();
            }
            ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1; ctx.strokeRect(padding, padding, width - 2*padding, height - 2*padding);

            if (points.length > 0) {
                ctx.beginPath();
                ctx.moveTo(timeToX(points[0].t), valToY(points[0].v));
                ctx.strokeStyle = '#38b6ff'; ctx.lineWidth = 2;
                points.forEach(p => ctx.lineTo(timeToX(p.t), valToY(p.v)));
                ctx.stroke();

                points.forEach((p, i) => {
                    ctx.beginPath();
                    ctx.arc(timeToX(p.t), valToY(p.v), 5, 0, 2 * Math.PI);
                    ctx.fillStyle = i === draggingPoint ? '#fde047' : '#f5f6fa';
                    ctx.fill();
                });
            }
        };

        const getMousePos = (e) => {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            if (e.touches) {
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            return { x, y };
        }

        const handleMouseDown = e => {
            e.preventDefault();
            const pos = getMousePos(e);
            const clickedPointIndex = points.findIndex(p => Math.hypot(pos.x - timeToX(p.t), pos.y - valToY(p.v)) < 15);
            
            // Right-click / Ctrl-click to delete point (except endpoints)
            if (e.button === 2 || e.ctrlKey) {
                if (clickedPointIndex > 0 && clickedPointIndex < points.length - 1) {
                    points.splice(clickedPointIndex, 1);
                }
            } else if (clickedPointIndex > -1) {
                draggingPoint = clickedPointIndex;
            } else {
                // Add new point
                const newPoint = { t: engine.clamp(xToTime(pos.x), 0, 1), v: engine.clamp(yToVal(pos.y), assignment.min, assignment.max) };
                points.push(newPoint);
                points.sort((a, b) => a.t - b.t);
                draggingPoint = points.findIndex(p => p === newPoint);
            }
            redraw();
        };

        const handleMouseMove = e => {
            if (draggingPoint === null) return;
            e.preventDefault();
            const pos = getMousePos(e);
            const p = points[draggingPoint];
            
            // Only non-endpoints can move horizontally
            if (draggingPoint > 0 && draggingPoint < points.length - 1) {
                 p.t = engine.clamp(xToTime(pos.x), points[draggingPoint-1].t + 0.001, points[draggingPoint+1].t - 0.001);
            }
            p.v = engine.clamp(yToVal(pos.y), assignment.min, assignment.max);
            points.sort((a, b) => a.t - b.t);
            draggingPoint = points.findIndex(pt => pt === p);
            redraw();
        };

        const handleMouseUp = () => { draggingPoint = null; redraw(); };

        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleMouseUp);
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        $('#closeAutomationPopup').addEventListener('click', () => popup.classList.add('hidden'));
        $('#resetAutomationBtn').addEventListener('click', () => {
            const firstVal = points.length > 0 ? points[0].v : (assignment.min + assignment.max) / 2;
            assignment.points = [ {t: 0, v: firstVal}, {t: 1, v: firstVal} ];
            points = assignment.points;
            redraw();
        });

        redraw();
    }

    function getInterpolatedValue(points, timeProgress) {
        if (!points || points.length < 2) return (points && points.length === 1) ? points[0].v : 0;

        if (timeProgress <= points[0].t) return points[0].v;
        if (timeProgress >= points[points.length - 1].t) return points[points.length - 1].v;

        let p1 = points[0];
        let p2 = points[points.length - 1];

        for (let i = 0; i < points.length - 1; i++) {
            if (timeProgress >= points[i].t && timeProgress <= points[i + 1].t) {
                p1 = points[i]; p2 = points[i + 1]; break;
            }
        }

        const timeSegment = p2.t - p1.t;
        if (timeSegment === 0) return p1.v;

        const progressInSegment = (timeProgress - p1.t) / timeSegment;
        return p1.v + (p2.v - p1.v) * progressInSegment;
    }

    // NEW: Function to open the Volume Preset Curve Editor
    function openVolumeGraphPopup(trackId, points, multiplier) {
        const popup = $('#volumeGraphPopup');
        popup.classList.remove('hidden');
        
        const currentMultiplier = multiplier || 1;
        const totalDuration = engine.masterIsSet ? engine.masterLoopDuration * currentMultiplier : currentMultiplier * 4;
        
        popup.innerHTML = `
            <div class="fx-popup-inner" style="min-width: 450px;">
                <h3>T${trackId} Volume Curve Editor</h3>
                <p style="font-size:0.9em; margin-top:-10px; color: var(--text-secondary);">
                    X-Axis: Loop Position | Y-Axis: Volume (0% to 120%)
                </p>
                <canvas id="volumeGraphCanvas" width="450" height="250"></canvas>
                <div style="text-align: center;">
                  <button id="closeVolumeGraphPopup" class="btn">Apply & Close</button>
                </div>
            </div>
        `;
        
        // Setup the graph interaction using the points array passed by reference
        setupVolumeGraph(trackId, points, true); // Pass true to enable interactivity in this mode

        // Event listener cleanup
        const closeBtn = $('#closeVolumeGraphPopup');
        if (closeBtn) {
            closeBtn.addEventListener('click', () => {
                popup.classList.add('hidden');
            });
        }
    }


    // --- Volume Preset Functions (UPDATED) ---
    function openVolumePresetEditor(presetIndex) {
        const preset = volumePresets[presetIndex];
        const popup = $('#volumePresetPopup');
        popup.classList.remove('hidden');

        let trackEditorsHtml = '';
        for (let i = 1; i <= engine.looperCount; i++) {
            if (engine.loopers[i]) {
                const trackEditor = $(`.preset-track-editor[data-track-id="${i}"]`);
                // Ensure data is initialized
                const trackSettings = preset.settings[i] || { type: 'STATIC', value: engine.loopers[i].gainNode.gain.value * 100, points: [{t: 0, v: 90}, {t: 1, v: 90}], multiplier: 1 };
                const isStatic = trackSettings.type === 'STATIC';
                const staticVal = isStatic ? trackSettings.value : 90;
                const multiplier = trackSettings.multiplier || 1;
                
                // Options for the multiplier dropdown
                const multiplierOptions = [1, 2, 3, 4].map(m => 
                    `<option value="${m}" ${m === multiplier ? 'selected' : ''}>${m}x Master</option>`
                ).join('');


                trackEditorsHtml += `
                    <div class="preset-track-editor" data-track-id="${i}">
                        <h5>Track ${i}</h5>
                        <div class="preset-editor-controls" style="flex-direction: column; align-items: stretch;">
                            <label style="width: 100%; justify-content: space-between;">
                                Mode:
                                <select id="modeSelect_${i}" style="width: auto;">
                                    <option value="STATIC" ${isStatic ? 'selected' : ''}>Static Volume</option>
                                    <option value="CURVE" ${!isStatic ? 'selected' : ''}>Curve Automation</option>
                                </select>
                            </label>
                             <label style="width: 100%; justify-content: space-between; margin-top: 10px;">
                                Curve Length (x Master):
                                <select id="multiplierSelect_${i}" class="curve-multiplier-select" style="width: auto;" ${isStatic ? 'disabled' : ''}>
                                    ${multiplierOptions}
                                </select>
                            </label>
                        </div>

                        <!-- STATIC SLIDER (ALWAYS VISIBLE FOR VALUE REFERENCE) -->
                        <div id="staticControl_${i}" style="display: ${isStatic ? 'flex' : 'none'}; flex-direction: column; align-items: center; margin-top: 10px;">
                            <label>Volume: <span id="staticVolVal_${i}">${staticVal.toFixed(0)}%</span></label>
                            <input type="range" id="staticVolSlider_${i}" min="0" max="120" value="${staticVal.toFixed(0)}" style="width: 90%;">
                        </div>

                        <!-- GRAPH EDITOR (Now contains only the button) -->
                        <div id="graphControl_${i}" style="display: ${!isStatic ? 'block' : 'none'};">
                            <div class="graph-button-group">
                                <button id="openGraphBtn_${i}" class="graph-edit-btn">Edit Curve</button>
                                <button id="resetGraphBtn_${i}" class="graph-edit-btn stop-btn">Reset Curve</button>
                            </div>
                        </div>
                    </div>
                `;
            }
        }

        popup.innerHTML = `
            <div class="fx-popup-inner" style="max-width: 900px; min-width: 900px;">
                <h3>Editing: ${preset.name} - Volume Curves</h3>
                <div class="preset-popup-grid">${trackEditorsHtml || '<p>Add a looper track first!</p>'}</div>
                <button id="savePresetBtn" class="btn">Save Preset</button>
                <button id="closePresetPopupBtn" class="btn stop-btn">Cancel</button>
            </div>
        `;

        // Wire up logic for each track
        for (let i = 1; i <= engine.looperCount; i++) {
            if (engine.loopers[i]) {
                const trackSettings = preset.settings[i] || { type: 'STATIC', value: engine.loopers[i].gainNode.gain.value * 100, points: [{t: 0, v: 90}, {t: 1, v: 90}], multiplier: 1 };
                wirePresetTrackEditor(i, trackSettings, presetIndex);
            }
        }

        $('#savePresetBtn').addEventListener('click', () => saveVolumePreset(presetIndex));
        $('#closePresetPopupBtn').addEventListener('click', () => popup.classList.add('hidden'));
    }

    function wirePresetTrackEditor(trackId, trackSettings, presetIndex) {
        const looper = engine.loopers[trackId];
        const modeSelect = $(`#modeSelect_${trackId}`);
        const multiplierSelect = $(`#multiplierSelect_${trackId}`);
        const staticControl = $(`#staticControl_${trackId}`);
        const graphControl = $(`#graphControl_${trackId}`);
        const staticVolSlider = $(`#staticVolSlider_${trackId}`);
        const staticVolVal = $(`#staticVolVal_${trackId}`);
        const resetGraphBtn = $(`#resetGraphBtn_${trackId}`);
        const openGraphBtn = $(`#openGraphBtn_${trackId}`); // NEW

        // Initial volume setting in the temporary structure
        let currentVol = trackSettings.value || 90;
        let currentPoints = trackSettings.points || [{t: 0, v: currentVol}, {t: 1, v: currentVol}];
        let currentMode = trackSettings.type || 'STATIC';
        let currentMultiplier = trackSettings.multiplier || 1;
        
        // --- Handlers ---
        const updateModeDisplay = (mode) => {
            staticControl.style.display = mode === 'STATIC' ? 'flex' : 'none';
            graphControl.style.display = mode === 'CURVE' ? 'block' : 'none';
            multiplierSelect.disabled = mode === 'STATIC';
        };

        staticVolSlider.value = currentVol;
        staticVolSlider.addEventListener('input', (e) => {
            currentVol = parseInt(e.target.value, 10);
            staticVolVal.textContent = `${currentVol}%`;
        });
        
        multiplierSelect.value = currentMultiplier;
        multiplierSelect.addEventListener('change', (e) => {
            currentMultiplier = parseInt(e.target.value, 10);
        });

        modeSelect.value = currentMode;
        modeSelect.addEventListener('change', (e) => {
            currentMode = e.target.value;
            updateModeDisplay(currentMode);
            if (currentMode === 'CURVE') {
                // Initialize curve to a flat line at the current static volume
                currentPoints = [{t: 0, v: currentVol}, {t: 1, v: currentVol}];
            }
        });
        
        resetGraphBtn.addEventListener('click', () => {
             currentPoints = [{t: 0, v: currentVol}, {t: 1, v: currentVol}];
             // No need to call setupVolumeGraph here, since the curve editing is done via openVolumeGraphPopup
        });

        // NEW: Graph Button Click
        if (openGraphBtn) {
            openGraphBtn.addEventListener('click', () => {
                // We pass the currentPoints by reference, so changes in the popup update this array directly.
                const trackEditor = $(`.preset-track-editor[data-track-id="${trackId}"]`);
                openVolumeGraphPopup(trackId, trackEditor.currentData.currentPoints, trackEditor.currentData.currentMultiplier);
            });
        }
        
        updateModeDisplay(currentMode); // Set initial UI visibility

        // Store the dynamic data back into the global preset array (before saving)
        const trackEditor = $(`.preset-track-editor[data-track-id="${trackId}"]`);
        // This object needs to be kept up-to-date by reference:
        trackEditor.currentData = { 
            currentVol: currentVol, 
            currentPoints: currentPoints, // Pass the mutable reference
            currentMode: currentMode,
            currentMultiplier: currentMultiplier
        };
        // Update the data object when inputs change
        staticVolSlider.addEventListener('input', (e) => {
            trackEditor.currentData.currentVol = parseInt(e.target.value, 10);
        });
        multiplierSelect.addEventListener('change', (e) => {
            trackEditor.currentData.currentMultiplier = parseInt(e.target.value, 10);
        });
        modeSelect.addEventListener('change', (e) => {
            trackEditor.currentData.currentMode = e.target.value;
        });
        resetGraphBtn.addEventListener('click', () => {
             trackEditor.currentData.currentPoints = currentPoints;
        });

    }


    function setupVolumeGraph(trackId, points, interactive = false) {
        const canvas = interactive ? $('#volumeGraphCanvas') : $(`#presetGraphCanvas_${trackId}`);
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        
        // Get CSS variables to fix the SyntaxError
        const style = getComputedStyle(document.body);
        const accentBlue = style.getPropertyValue('--accent-blue').trim();
        const accentYellow = style.getPropertyValue('--accent-yellow').trim();
        const textPrimary = style.getPropertyValue('--text-primary').trim();

        const width = canvas.width, height = canvas.height;
        const padding = 15;
        const volMin = 0, volMax = 120; // Volume range 0% to 120%

        let draggingPoint = null;
        
        // --- Mapping Functions ---
        // Y-axis: maps volume (0-120) to screen pixel height
        const valToY = v => padding + (1 - (engine.clamp(v, volMin, volMax) - volMin) / (volMax - volMin)) * (height - 2 * padding);
        // X-axis: maps time (0 to 1) to screen pixel width
        const timeToX = t => padding + t * (width - 2 * padding);
        const xToTime = x => (x - padding) / (width - 2 * padding);
        // Y-axis: maps screen pixel height back to volume (0-120)
        const yToVal = y => volMin + (1 - (y - padding) / (height - 2 * padding)) * (volMax - volMin);


        const redraw = () => {
            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = '#1a202c'; ctx.fillRect(0, 0, width, height);

            // Draw grid lines
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 0.5;
            for (let i = 1; i < 4; i++) { // Vertical lines (Time)
                ctx.beginPath(); ctx.moveTo(padding + i*(width-2*padding)/4, padding); ctx.lineTo(padding + i*(width-2*padding)/4, height-padding); ctx.stroke();
            }
            for (let i = 1; i < 4; i++) { // Horizontal lines (Volume)
                ctx.beginPath(); ctx.moveTo(padding, padding + i*(height-2*padding)/4); ctx.lineTo(width-padding, padding + i*(height-2*padding)/4); ctx.stroke();
            }
            
            // Draw border
            ctx.strokeStyle = '#64748b'; ctx.lineWidth = 1; ctx.strokeRect(padding, padding, width - 2*padding, height - 2*padding);

            // Draw the curve
            if (points.length > 0) {
                ctx.beginPath();
                ctx.moveTo(timeToX(points[0].t), valToY(points[0].v));
                ctx.strokeStyle = accentBlue;
                ctx.lineWidth = 2;
                points.forEach(p => ctx.lineTo(timeToX(p.t), valToY(p.v)));
                ctx.stroke();

                // Draw points
                points.forEach((p, i) => {
                    ctx.beginPath();
                    ctx.arc(timeToX(p.t), valToY(p.v), 5, 0, 2 * Math.PI);
                    ctx.fillStyle = i === draggingPoint ? accentYellow : textPrimary;
                    ctx.fill();
                });
            }
        };
        
        if (!interactive) {
            redraw();
            return;
        }

        // --- Interactive Event Handlers (Only enabled if interactive=true) ---

        const getMousePos = (e) => {
            const rect = canvas.getBoundingClientRect();
            let x, y;
            if (e.touches) {
                x = e.touches[0].clientX - rect.left;
                y = e.touches[0].clientY - rect.top;
            } else {
                x = e.clientX - rect.left;
                y = e.clientY - rect.top;
            }
            return { x, y };
        };

        const handleMouseDown = e => {
            e.preventDefault();
            const pos = getMousePos(e);
            
            // Check if user clicked on an existing point
            const clickedPointIndex = points.findIndex(p => Math.hypot(pos.x - timeToX(p.t), pos.y - valToY(p.v)) < 15);
            
            // Right-click / Ctrl-click to remove point (except endpoints)
            if (e.button === 2 || e.ctrlKey) {
                if (clickedPointIndex > 0 && clickedPointIndex < points.length - 1) {
                    points.splice(clickedPointIndex, 1);
                }
            } else if (clickedPointIndex > -1) {
                // Start dragging
                draggingPoint = clickedPointIndex;
            } else {
                // Create new point
                const newPoint = { t: engine.clamp(xToTime(pos.x),0,1), v: engine.clamp(yToVal(pos.y), volMin, volMax) };
                points.push(newPoint);
                points.sort((a, b) => a.t - b.t);
                draggingPoint = points.findIndex(p => p === newPoint);
            }
            redraw();
        };

        const handleMouseMove = e => {
            if (draggingPoint === null) return;
            e.preventDefault();
            const pos = getMousePos(e);
            const p = points[draggingPoint];
            
            // Endpoints (0 and Length-1) can only move vertically (volume)
            if (draggingPoint === 0 || draggingPoint === points.length - 1) {
                 p.t = draggingPoint === 0 ? 0 : 1;
            } else {
                 // Internal points can move horizontally (time)
                 p.t = engine.clamp(xToTime(pos.x), points[draggingPoint-1].t + 0.001, points[draggingPoint+1].t - 0.001);
            }
            
            p.v = engine.clamp(yToVal(pos.y), volMin, volMax);
            points.sort((a,b) => a.t - b.t);
            draggingPoint = points.findIndex(pt => pt === p);
            redraw();
        };

        const handleMouseUp = () => { draggingPoint = null; redraw(); };
        
        // --- Listener Cleanup/Setup ---
        
        // Remove old listeners to prevent duplication if this is called multiple times
        if (canvas.__listeners) {
            canvas.removeEventListener('mousedown', canvas.__listeners.mouseDown);
            canvas.removeEventListener('mousemove', canvas.__listeners.mouseMove);
            canvas.removeEventListener('mouseup', canvas.__listeners.mouseUp);
            canvas.removeEventListener('mouseleave', canvas.__listeners.mouseUp);
            canvas.removeEventListener('touchstart', canvas.__listeners.mouseDown, { passive: false });
            canvas.removeEventListener('touchmove', canvas.__listeners.mouseMove, { passive: false });
            canvas.removeEventListener('touchend', canvas.__listeners.mouseUp);
        }
        
        canvas.__listeners = {
            mouseDown: handleMouseDown,
            mouseMove: handleMouseMove,
            mouseUp: handleMouseUp
        };


        canvas.addEventListener('mousedown', handleMouseDown);
        canvas.addEventListener('mousemove', handleMouseMove);
        canvas.addEventListener('mouseup', handleMouseUp);
        canvas.addEventListener('mouseleave', handleMouseUp);
        canvas.addEventListener('touchstart', handleMouseDown, { passive: false });
        canvas.addEventListener('touchmove', handleMouseMove, { passive: false });
        canvas.addEventListener('touchend', handleMouseUp);
        canvas.addEventListener('contextmenu', e => e.preventDefault());

        redraw();
    }


    function saveVolumePreset(presetIndex) {
        const newSettings = {};
        let needsCurveActivation = false;

        for (let i = 1; i <= engine.looperCount; i++) {
            const trackEditor = $(`.preset-track-editor[data-track-id="${i}"]`);
            if (trackEditor) {
                const data = trackEditor.currentData;
                const mode = $(`#modeSelect_${i}`).value;
                
                newSettings[i] = {
                    type: mode,
                    value: data.currentVol,
                    points: data.currentPoints,
                    multiplier: data.currentMultiplier
                };
                
                if (mode === 'CURVE') {
                    needsCurveActivation = true;
                }
            }
        }
        
        volumePresets[presetIndex].settings = newSettings;
        
        // If any curve exists, we must start the real-time volume automation loop.
        if (needsCurveActivation) {
            engine.showMsg(`Preset saved! Curves detected. They will apply on next run.`, "#21f7a8");
        } else {
             engine.showMsg(`Preset saved!`, "#21f7a8");
        }
        
        // This clears the global curve chains so they don't apply immediately
        // and only apply when the preset is actually pressed via applyVolumePreset
        activePresetTimeChain = {}; 
        
        $('#volumePresetPopup').classList.add('hidden');
    }


    function applyVolumePreset(presetIndex) {
        const preset = volumePresets[presetIndex];
        if (Object.keys(preset.settings).length === 0) {
            engine.showMsg(`${preset.name} is not programmed yet. Click ‚öôÔ∏è to edit.`, "#fde047");
            return;
        }

        engine.showMsg(`Applying ${preset.name}`, "#38b6ff");
        
        // NEW: Clear any existing active curves
        activePresetTimeChain = {};

        for (const trackId in preset.settings) {
            const looper = engine.loopers[trackId];
            if (looper) {
                const { type, value, points, multiplier } = preset.settings[trackId];
                const gainParam = looper.gainNode.gain;
                
                // --- CURVE MODE ---
                if (type === 'CURVE' && engine.masterIsSet && engine.masterLoopDuration) {
                    const master = engine.loopers[1];
                    // Calculate total duration the curve should run over
                    const curveDuration = engine.masterLoopDuration * (multiplier || 1);
                    
                    // Store the active chain data to be read by the masterAnimationLoop
                    activePresetTimeChain[trackId] = {
                        startTime: engine.audioCtx.currentTime,
                        duration: curveDuration,
                        points: points,
                        // Ensure it starts at the current loop time to sync progress
                        loopStartTime: master.loopStartTime,
                        loopDuration: master.loopDuration
                    };

                } else {
                    // --- STATIC/IMMEDIATE MODE ---
                    const targetGain = value / 100.0;
                    
                    // Use WebAudio API for a smooth, non-graphic transition
                    // Duration is a quick fade (0.2s) to target value
                    gainParam.cancelScheduledValues(audioCtx.currentTime);
                    gainParam.setTargetAtTime(targetGain, audioCtx.currentTime, 0.2); 

                    // Update the UI
                    const volSlider = $(`#volSlider${trackId}`);
                    const volValue = $(`#volValue${trackId}`);
                    if (volSlider) volSlider.value = value;
                    if (volValue) volValue.textContent = `${value}%`;
                }
            }
        }
    }
// --- NEW: initializeApp function definition is moved up ---
    async function initializeApp() {
        try {
            await engine.ensureMic();
            // Initialize Pre-FX nodes and chain after mic is available
            updatePreFxGraph(); 

            // --- START: Initialize Visualizer ---
            const vizCanvas = document.getElementById('preFxVisualizer');
            if (vizCanvas && typeof AudioVisualizer !== 'undefined') {
                // Connect it to the recordingSourceMixer to visualize the final pre-loop signal
                if (engine.recordingSourceMixer) {
                    preFxViz = new AudioVisualizer(engine.audioCtx, engine.recordingSourceMixer, vizCanvas);
                } else {
                    engine.showMsg("Visualizer error: Recording mixer not ready.", "#f43f5e");
                }
                
                const vizToggleBtn = document.getElementById('vizToggleBtn');
                if (vizToggleBtn) {
                    addTap(vizToggleBtn, () => {
                        preFxViz.toggleMode();
                        vizToggleBtn.textContent = `View ${preFxViz.mode === 'spectrum' ? 'Waveform' : 'Spectrum'}`;
                    });
                }
            }
            // --- END: Initialize Visualizer ---
            
            document.getElementById('start-overlay').style.display = 'none';
            document.querySelector('.main-wrapper').style.visibility = 'visible';

            // Use the combined initializer
            initCombinedFxControls();
            initPerformanceControls(); // Initializing performance controls here

            for (let i = 1; i <= 3; i++) engine.loopers[i] = new Looper(i, engine);

            engine.onBpmUpdate = () => {
                updateDelayTime(preFxNodes.delay.params);
                engine.loopers.forEach(looper => {
                    if (!looper) return;
                    looper.fx.chain.forEach(fx => {
                        if (fx.type === 'Delay' && fx.nodes?.updateDelayTimeFx) {
                            fx.nodes.updateDelayTimeFx();
                        }
                    });
                });
            };
            engine.onFirstLoopCallback = masterAnimationLoop;

            $('#addLooperBtn').addEventListener('click', () => {
                if (engine.looperCount >= 12) return;
                engine.looperCount++;
                const newIndex = engine.looperCount;
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = createLooperHTML(newIndex).trim();
                $('.main-pedals-container').insertBefore(tempDiv.firstChild, $('#addLooperBtn'));
                engine.loopers[newIndex] = new Looper(newIndex, engine);
                if (!engine.masterIsSet) engine.loopers[newIndex].disable(true);
                if (engine.looperCount >= 12) $('#addLooperBtn').classList.add('hidden');
            });
            
            $('#openPreFxMenuBtn').addEventListener('click', openPreFxMenu);

            $('#monitorBtn').addEventListener('click', () => {
                engine.liveMicMonitoring = !engine.liveMicMonitoring;
                if (engine.liveMicMonitorGain) engine.liveMicMonitorGain.gain.value = engine.liveMicMonitoring ? 1.0 : 0;
                $('#monitorBtn').textContent = `Live MIC ${engine.liveMicMonitoring?'ON':'OFF'}`;
                $('#monitorBtn').classList.toggle('active', engine.liveMicMonitoring);
            });

            $('#nudgeMs').addEventListener('input', e => { const v = parseInt(e.target.value); $('#nudgeVal').textContent=v; engine.loopers.forEach(l=>l&&(l.manualNudgeMs=v)); });
            $('#overdubGain').addEventListener('input', e => { const v = parseFloat(e.target.value); $('#overdubGainVal').textContent=v.toFixed(2); engine.loopers.forEach(l=>l&&(l.overdubGain=v)); });
            
            $('#calibrateBtn').addEventListener('click', () => engine.runLatencyCalibration());

            // --- Initialize Volume Preset Buttons (NEW) ---
            for (let i = 0; i < 4; i++) {
                $(`#presetBtn_${i}`).addEventListener('click', () => applyVolumePreset(i));
                $(`#editPresetBtn_${i}`).addEventListener('click', () => openVolumePresetEditor(i));
            }
            
            // Wire delete buttons for initial tracks (2 and 3)
            document.querySelectorAll('.delete-track-btn').forEach(btn => {
                 btn.addEventListener('click', (e) => deleteLooperTrack(parseInt(e.target.dataset.trackId)));
            });


        } catch (error) {
            console.error("Initialization failed:", error);
            const startButton = document.getElementById('startBtn');
            const startOverlay = document.getElementById('start-overlay');
            const p = startOverlay.querySelector('p');
            p.innerHTML = "Microphone access was denied. This app cannot function without it. Please enable microphone permissions in your browser settings and refresh the page.";
            p.style.color = 'var(--accent-pink)';
            startButton.style.display = 'none';
        }
    }
// --- END NEW: initializeApp function definition is moved up ---

    function onDeviceReady() {
        if (window.cordova && window.cordova.platformId === 'android') {
            const permissions = cordova.plugins.permissions;
            const permission = permissions.RECORD_AUDIO;

            permissions.checkPermission(permission, (status) => {
                if (status.hasPermission) {
                    initializeApp();
                } else {
                    permissions.requestPermission(permission, (requestStatus) => {
                        if (requestStatus.hasPermission) {
                            initializeApp();
                        } else {
                             const p = document.querySelector('#start-overlay p');
                             p.innerHTML = "Microphone permission is required for this app to work. Please grant permission.";
                             p.style.color = 'var(--accent-pink)';
                             document.getElementById('startBtn').style.display = 'none';
                        }
                    }, () => { console.error("Error requesting permission."); });
                }
            });
        } else {
             // We need to call initializeApp() and handle the promise from startBtn click
             initializeApp();
        }
    }
    
    $('#startBtn').addEventListener('click', async () => {
        // 1. Explicitly resume AudioContext immediately on user gesture
        await engine.audioCtx.resume(); 
        
        if (window.cordova) { 
            onDeviceReady(); 
        } 
        else { 
            // 2. Proceed with app initialization now that context is active
            await initializeApp(); 
        }
    });

    document.addEventListener('deviceready', () => {}, false);

});
// --- End of Combined JavaScript ---
</script>
</body>
</html>
